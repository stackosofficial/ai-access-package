---
alwaysApply: false
---
# ai-access-point SDK Rules (Updated v0.2.0)

## 1. No Socket.IO or WebSocket Support
- All Socket.IO and WebSocket code, tests, and documentation are deprecated and must not be used.
- All communication is via HTTP REST endpoints only.
- Remove any references to socket.io-client, WebSocketManager, or related test scripts.

## 2. Authentication Handling for Third-Party Apps
- All third-party authentication must use the new `AuthService` abstract class in `src/services/authService.ts`.
- The only required methods for a custom AuthService are:
  - `generateAuthLink(userAddress: string, nftId: string): Promise<string>`
  - `checkAuthStatus(userAddress: string, nftId: string): Promise<boolean>`
  - `getAuth(userAddress: string, nftId: string): Promise<any | null>`
  - `saveAuth(userAddress: string, nftId: string, authData: any): Promise<void>`
  - `initTable(): Promise<void>` (provided by SDK, not to be overridden)
- The default implementation throws for `generateAuthLink` and must be overridden by the developer.

## 3. Auth Table (Handled by SDK)
- The SDK automatically creates and manages the `auth_data` table.
- Table creation is handled internally during SDK initialization via `authService.initTable()`.
- Developers do not need to create or manage the database table.
- The table schema is defined internally in the SDK.

## 4. REST Endpoints for Auth

### **SDK-Automated Endpoints (No Developer Action Required)**
The SDK automatically creates these endpoints during initialization:

- **`/auth-link` (POST)**: Returns an auth link for the user. Requires `userAuthPayload` and `accountNFT` as **JSON strings** in the body.
- **`/auth-status` (POST)**: Returns boolean for whether the user is authenticated. Requires `userAuthPayload` and `accountNFT` as **JSON strings** in the body.

### **Developer-Required Endpoint**
Developers must manually add the OAuth callback endpoint:

- **`/auth/callback` (GET)**: OAuth callback endpoint for processing authorization codes and saving auth data.

### **Auth Endpoint Payload Format (IMPORTANT)**
The SDK's `parseAuth` middleware expects `userAuthPayload` and `accountNFT` to be **JSON strings**, not objects:

#### **✅ CORRECT Format (JSON Strings):**
```json
{
  "userAuthPayload": "{\"userAddress\":\"0x1234567890abcdef\",\"signature\":\"0x...\",\"message\":\"1713033600000\"}",
  "accountNFT": "{\"collectionID\":\"0\",\"nftID\":\"53\"}"
}
```

#### **❌ WRONG Format (JSON Objects):**
```json
{
  "userAuthPayload": {
    "userAddress": "0x1234567890abcdef",
    "signature": "0x...",
    "message": "1713033600000"
  },
  "accountNFT": {
    "collectionID": "0",
    "nftID": "53"
  }
}
```

### **Endpoint Implementation**
```typescript
// The SDK automatically handles these endpoints - NO NEED TO IMPLEMENT
// POST /auth-link - handled by SDK
// POST /auth-status - handled by SDK

// Developer must implement this endpoint
app.get('/auth/callback', async (req: Request, res: Response) => {
  // OAuth callback implementation
  // Exchange code for tokens
  // Save auth data using authService.saveAuth()
  // Redirect to frontend
});
```

## 5. AgentCollection Verification (Optional)
- **AgentCollection is an optional field** that can be provided in requests to verify agent ownership on-chain
- When provided, the SDK automatically verifies that the user owns the specified agent collection and agent ID
- **Format**: `agentCollection` object with `agentAddress` (required) and `agentID` (optional)
- **Verification**: SDK checks if user owns the agent collection or has admin role, and if agentID is provided, verifies ownership of that specific agent

### **AgentCollection Request Format**
```json
{
  "prompt": "Your AI request",
  "userAuthPayload": {
    "userAddress": "0x1234567890abcdef",
    "signature": "0x...",
    "message": "1713033600000"
  },
  "accountNFT": {
    "collectionID": "0",
    "nftID": "53"
  },
  "agentCollection": {
    "agentAddress": "0xabcdef1234567890",  // Required: Agent collection contract address
    "agentID": "123"                        // Optional: Specific agent ID to verify ownership
  }
}
```

### **AgentCollection Verification Logic**
1. **If `agentID` is provided**: Verify user owns the specific agent NFT
2. **If `agentID` is not provided**: Verify user has admin role on the agent collection
3. **Verification failure**: Request is rejected with authentication error
4. **Verification success**: Request proceeds with agent context

### **Example AgentCollection Usage**
```typescript
// Request with agent collection verification
const response = await axios.post('http://localhost:3000/natural-request', {
  prompt: "Analyze my agent's performance and suggest improvements",
  userAuthPayload: signature.data,
  accountNFT: {
    "collectionID": "0",
    "nftID": "53"
  },
  agentCollection: {
    "agentAddress": "0xabcdef1234567890",
    "agentID": "123"
  }
});
```

### **AgentCollection in Natural Function**
```typescript
const runNaturalFunction = async (
  req: Request,
  res: Response,
  balanceRunMain: BalanceRunMain,
  responseHandler: ResponseHandler
): Promise<void> => {
  try {
    const { prompt, accountNFT, userAuthPayload, agentCollection } = req.body;
    
    // AgentCollection is automatically verified by the SDK middleware
    // If verification fails, the request won't reach this function
    
    if (agentCollection) {
      console.log(`Processing request with agent: ${agentCollection.agentAddress}, ID: ${agentCollection.agentID || 'all'}`);
      responseHandler.sendUpdate("Processing request with agent context...");
    }
    
    // Your AI processing logic here
    // ...
  } catch (error) {
    responseHandler.sendError(error.message, 500);
  }
};
```

## 6. Streaming
- Streaming is supported only via HTTP Server-Sent Events (SSE) using the `stream=true` query parameter.
- Use the `ResponseHandler` interface for all responses, including streaming.

## 7. Testing Requirements and Restrictions

### **MANDATORY: Use Test Scripts Only**
- **❌ NEVER use curl or Postman** for testing AI Access Point endpoints
- **❌ NEVER use manual tools** for authentication testing
- **✅ ALWAYS use TypeScript test scripts** with the Sky AI Access Point SDK

### **Why Manual Testing Tools Are Forbidden**
1. **Signature Generation**: The SDK automatically generates cryptographic signatures with proper timing
2. **10-Minute Time Window**: Signatures expire after 10 minutes - SDK handles this automatically
3. **Proper Authentication Flow**: SDK manages the complete auth lifecycle including token refresh
4. **Consistent Testing**: Test scripts ensure reproducible results across different environments
5. **Error Handling**: SDK provides proper error handling and retry mechanisms

### **Required Test Script Structure**
All test scripts must follow this pattern:

```typescript
// test-[feature-name].ts
import axios from 'axios';
import { getSkyNode } from './src/clients/skynet';

async function test[FeatureName]() {
  // Step 1: Get authenticated SkyNode instance
  const skyNode = await getSkyNode();
  const signature = await skyNode.appManager.getUrsulaAuth();
  
  try {
    // Step 2: Make request with proper SDK-generated signatures
    const response = await axios.post('http://localhost:3000/[endpoint]', {
      // Use SDK-generated auth payload
      userAuthPayload: JSON.stringify(signature.data), // For auth endpoints
      // OR
      userAuthPayload: signature.data, // For natural-request endpoint
      accountNFT: {
        "collectionID": "0",
        "nftID": "53"
      },
      // Add endpoint-specific parameters
      prompt: "Your test prompt here"
    });

    console.log('✅ Test Success:', response.data);
    
  } catch (error) {
    console.error('❌ Test Failed:', error.response?.data || error.message);
  }
}

test[FeatureName]();
```

### **Testing Best Practices**
- **Use ts-node** to run test scripts: `npx ts-node test-script.ts`
- **Include comprehensive test cases** for all supported actions
- **Test both success and failure scenarios**
- **Provide clear console output** with ✅/❌ indicators
- **Include setup instructions** in test script comments
- **Test auth flow first**, then natural requests

### **Example Test Commands (Using Scripts Only)**
```bash
# ✅ CORRECT - Using test scripts
npx ts-node test-auth-link.ts
npx ts-node test-natural-requests.ts
npx ts-node test-specific-feature.ts

# ❌ WRONG - Using manual tools
curl -X POST http://localhost:3000/auth-link  # DON'T DO THIS
# Postman requests                            # DON'T DO THIS
```

### **Legacy Testing Information**
- All test scripts must use HTTP REST (axios/fetch) only.
- No socket or websocket tests are required or allowed.

## 8. Project Structure
- All authentication logic for third-party apps must be implemented as a subclass of `AuthService` in `src/services/`.
- No code or tests should reference or import socket.io or websocket libraries.

## 9. OAuth Callback Security Requirements
- **Callback URLs must NOT have any authentication middleware** (no auth tokens, no user validation)
- The callback endpoint should be publicly accessible to receive OAuth responses from third-party services
- **Security is handled through state verification**: Compare received state/code with temporary auth state stored during auth link generation
- **Callback flow**:
  1. User initiates auth via `/auth-link` → generates temporary state and redirects to OAuth provider
  2. OAuth provider redirects to `/auth/callback` with code and state
  3. Callback endpoint verifies state matches stored temporary state
  4. Exchange code for tokens and save auth data using `authService.saveAuth()`
  5. Clean up temporary state and redirect user to success page

### **Example Callback Implementation (No Auth Required)**
```typescript
// ❌ WRONG - Callback with authentication
app.get('/auth/callback', authenticateUser, async (req, res) => { ... });

// ✅ CORRECT - Callback without authentication
app.get('/auth/callback', async (req: Request, res: Response) => {
  const { code, state } = req.query;
  
  // Verify state matches stored temporary state
  const storedState = await getTemporaryState(state as string);
  if (!storedState) {
    return res.status(400).send('Invalid or expired state');
  }
  
  // Exchange code for tokens
  const tokens = await exchangeCodeForTokens(code as string);
  
  // Save auth data
  await authService.saveAuth(storedState.userAddress, storedState.nftId, tokens);
  
  // Clean up temporary state
  await cleanupTemporaryState(state as string);
  
  // Redirect to success page
  res.redirect('/auth-success');
});
```

## 10. Required Testing Scripts
- **Always provide test scripts** for every third-party service implementation
- **Two-phase testing approach**:

### **Phase 1: Auth Link Generation Test**
Create a test script that generates and displays the auth link for users to authorize:

```typescript
// test-auth-link.ts
import axios from 'axios';
import { getSkyNode } from './src/clients/skynet';

async function testAuthLink() {
  const skyNode = await getSkyNode();
  const signature = await skyNode.appManager.getUrsulaAuth();
  
  try {
    const response = await axios.post('http://localhost:3000/auth-link', {
      userAuthPayload: JSON.stringify(signature.data),
      accountNFT: JSON.stringify({
        "collectionID": "0",
        "nftID": "53"
      })
    });

    console.log('🔗 Auth Link Generated:');
    console.log(response.data.authLink);
    console.log('\n📋 Instructions:');
    console.log('1. Copy the auth link above');
    console.log('2. Open it in your browser');
    console.log('3. Complete the authorization process');
    console.log('4. Run the natural request tests after authorization');
    
  } catch (error) {
    console.error('❌ Auth Link Generation Failed:', error.response?.data || error.message);
  }
}

testAuthLink();
```

### **Phase 2: Natural Request Action Tests**
After successful authorization, test all supported actions through `/natural-request`:

```typescript
// test-natural-requests.ts
import axios from 'axios';
import { getSkyNode } from './src/clients/skynet';

async function testNaturalRequests() {
  const skyNode = await getSkyNode();
  const signature = await skyNode.appManager.getUrsulaAuth();
  
  const testCases = [
    {
      name: "Service Analysis",
      prompt: "Analyze my account activity and provide insights"
    },
    {
      name: "Content Generation",
      prompt: "Generate a professional post about AI trends"
    },
    {
      name: "Data Retrieval",
      prompt: "Get my recent activity data and summarize it"
    }
    // Add service-specific test cases
  ];

  for (const testCase of testCases) {
    console.log(`\n🧪 Testing: ${testCase.name}`);
    
    try {
      const response = await axios.post('http://localhost:3000/natural-request', {
        prompt: testCase.prompt,
        userAuthPayload: signature.data,
        accountNFT: {
          "collectionID": "0",
          "nftID": "53"
        }
      });

      console.log(`✅ ${testCase.name} Success:`, response.data.data?.result);
      
    } catch (error) {
      console.error(`❌ ${testCase.name} Failed:`, error.response?.data || error.message);
    }
  }
}

testNaturalRequests();
```

### **Testing Script Requirements**
- **Use simple TypeScript with axios** (no testing frameworks)
- **Include comprehensive test cases** covering all service actions
- **Provide clear instructions** for manual authorization steps
- **Test both success and error scenarios**
- **Include example prompts** for each supported action

## 11. Required Dependencies (Exact Versions)
```json
{
  "dependencies": {
    "@decloudlabs/skynet": "0.6.25",
    "@decloudlabs/sky-ai-accesspoint": "0.2.0",
    "@ethersproject/wallet": "^5.7.0",
    "@supabase/supabase-js": "^2.39.0",
    "axios": "^1.9.0",
    "ethers": "^6.15.0",
    "express": "^4.19.2",
    "firebase-admin": "^13.1.0",
    "jsonwebtoken": "^9.0.2",
    "multer": "^1.4.5-lts.1",
    "openai": "^4.70.2",
    "pg": "^8.15.6"
  },
  "devDependencies": {
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/jsonwebtoken": "^9.0.0",
    "@types/multer": "^1.4.12",
    "@types/pg": "^8.15.0",
    "nodemon": "^3.1.7",
    "ts-node": "^10.9.1",
    "typescript": "^5.0.0"
  }
}
```

## 12. Required Skynet Client Setup (Fixed Code)
```typescript
import SkyMainNodeJS from '@decloudlabs/skynet/lib/services/SkyMainNodeJS';
import SkyEnvConfigNodeJS from '@decloudlabs/skynet/lib/types/types';
import dotenv from 'dotenv';
dotenv.config();

let initializedAppCrypto: SkyMainNodeJS;

const initializeSkyNodeCrypto = async (): Promise<SkyMainNodeJS> => {
    if (!initializedAppCrypto) {
        const envConfig: SkyEnvConfigNodeJS = {
            JRPC_PROVIDER: process.env.PROVIDER_RPC!,
            WALLET_PRIVATE_KEY: process.env.WALLET_PRIVATE_KEY!,
            STORAGE_API: {
                LIGHTHOUSE: {
                    LIGHTHOUSE_API_KEY: process.env.LIGHTHOUSE_API_KEY!
                },
                IPFS: {
                    PROJECT_ID: process.env.IPFS_PROJECT_ID!,
                    PROJECT_SECRET: process.env.IPFS_PROJECT_SECRET!
                },
                CLOUD: {
                    BUCKET_NAME: process.env.CLOUD_BUCKET_NAME!,
                    ACCESS_KEY_ID: process.env.CLOUD_ACCESS_KEY_ID!,
                    SECRET_ACCESS_KEY: process.env.CLOUD_SECRET_ACCESS_KEY!,
                    REGION: process.env.CLOUD_REGION!
                }
            }
        };
        initializedAppCrypto = new SkyMainNodeJS(envConfig);
        await initializedAppCrypto.init(true);
    }
    return initializedAppCrypto;
};

export const getSkyNode = async (): Promise<SkyMainNodeJS> => {
    return await initializeSkyNodeCrypto();
};
```

**Note:** Storage API environment variables (LIGHTHOUSE_API_KEY, IPFS_PROJECT_ID, etc.) are optional and can be any placeholder string if not needed.

## 13. Main Access Point Initialization

### Option A: With File Upload Support
```typescript
import dotenv from "dotenv";
dotenv.config();
import express, { Request, Response } from "express";
import SkyMainNodeJS from "@decloudlabs/skynet/lib/services/SkyMainNodeJS";
import { getSkyNode } from "./clients/skynet";
import { initAIAccessPoint } from "@decloudlabs/sky-ai-accesspoint/lib/init";
import cors from "cors";
import bodyParser from "body-parser";
import multer from "multer";
import BalanceRunMain from '@decloudlabs/sky-ai-accesspoint/lib/balanceRunMain';
import { ResponseHandler } from '@decloudlabs/sky-ai-accesspoint/lib/types/types';

const app = express();
app.use(cors());
app.use(bodyParser.json());
const port = process.env.PORT || 3000;

// File upload configuration for multipart form data
const upload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 50 * 1024 * 1024, // 50MB limit
  },
});

// Natural function with file upload support
const runNaturalFunction = async (
  req: Request,
  res: Response,
  balanceRunMain: BalanceRunMain,
  responseHandler: ResponseHandler
): Promise<void> => {
  try {
    const { prompt, accountNFT, userAuthPayload } = req.body;
    const files = req.files as Express.Multer.File[]; // Files from multipart form

    // Send progress update
    responseHandler.sendUpdate("Processing your request with files...");

    // Handle uploaded files
    if (files && files.length > 0) {
      responseHandler.sendUpdate(`Processing ${files.length} uploaded files...`);
      files.forEach((file, index) => {
        console.log(`File ${index + 1}: ${file.originalname}, Size: ${file.size} bytes`);
      });
    }

    // Step 1: Use AI to parse and extract parameters from user request
    const completion = await balanceRunMain.callAIModel(`[
      {
        "role": "system",
        "content": "You are a helpful assistant that extracts parameters from user requests. Return only valid JSON with the required fields."
      },
      {
        "role": "user",
        "content": "${prompt}"
      }
    ]`);

    if (!completion.success) {
      responseHandler.sendError(completion.message, 500);
      return;
    }

    // Step 2: Parse AI response to get structured parameters
    let params;
    console.log("AI completion message:", completion.message);
    try {
      params = JSON.parse(completion.message || "");
    } catch (parseError) {
      responseHandler.sendError("Failed to parse AI response parameters", 500);
      return;
    }

    // Step 3: Process the extracted parameters
    responseHandler.sendUpdate("Processing extracted parameters...");
    
    // Example: Process based on extracted action
    let processedResult;
    if (params.action === 'analyze') {
      processedResult = `Analyzing: ${params.domain || 'unknown domain'}`;
    } else if (params.action === 'generate') {
      processedResult = `Generating content for: ${params.keyword || 'unknown keyword'}`;
    } else {
      processedResult = `Processed: ${prompt}`;
    }
    
    // Calculate cost (example: 0.01 tokens per request + 0.001 per file)
    const baseCost = BigInt(0.01 * 1e12);
    const fileCost = BigInt((files?.length || 0) * 0.001 * 1e12);
    const totalCost = baseCost + fileCost;
    
    // Send final response
    responseHandler.sendFinalResponse({
      success: true,
      message: "Request completed successfully",
      data: {
        result: processedResult,
        extractedParams: params,
        filesProcessed: files?.length || 0,
        timestamp: new Date().toISOString()
      }
    });

    // Add cost to user's balance
    await balanceRunMain.addCost(accountNFT, totalCost.toString());
    console.log(`Added cost: ${totalCost} for user: ${accountNFT.collectionID}_${accountNFT.nftID}`);

  } catch (error) {
    console.error("Error processing request:", error);
    responseHandler.sendError(
      error instanceof Error ? error.message : "Failed to process request",
      500
    );
  }
};

const setup = async () => {
  const skyNode: SkyMainNodeJS = await getSkyNode();
  const env = {
    JSON_RPC_PROVIDER: process.env.PROVIDER_RPC!,
    WALLET_PRIVATE_KEY: process.env.WALLET_PRIVATE_KEY!,
    SUBNET_ID: process.env.SUBNET_ID!,
    POSTGRES_URL: process.env.DATABASE_URL!,
    SERVER_COST_CONTRACT_ADDRESS: process.env.SERVER_COST_CONTRACT_ADDRESS!,
  };

  const balanceRunMain = await initAIAccessPoint(
    env,
    skyNode,
    app,
    runNaturalFunction,
    true, // Enable balance updates
    upload, // File upload middleware (required for upload support)
    {
      // Optional: Pass custom auth service here
      // authService: new MyCustomAuthService(pool)
    }
  );

  if (!balanceRunMain.success) {
    console.error("Error initializing AI Access Point:", balanceRunMain);
    process.exit(1);
  }

  // Simple health check endpoint
  app.get('/health', (req: Request, res: Response) => {
    res.json({ 
      status: 'healthy', 
      uploadSupport: true,
      timestamp: new Date().toISOString()
    });
  });

  app.listen(port, () => {
    console.log(`Service is running on http://localhost:${port}`);
    console.log(`Health check: http://localhost:${port}/health`);
  });
};

setup().catch(console.error);
```

### Option B: Without File Upload Support
```typescript
import dotenv from "dotenv";
dotenv.config();
import express, { Request, Response } from "express";
import SkyMainNodeJS from "@decloudlabs/skynet/lib/services/SkyMainNodeJS";
import { getSkyNode } from "./clients/skynet";
import { initAIAccessPoint } from "@decloudlabs/sky-ai-accesspoint/lib/init";
import cors from "cors";
import bodyParser from "body-parser";
import BalanceRunMain from '@decloudlabs/sky-ai-accesspoint/lib/balanceRunMain';
import { ResponseHandler } from '@decloudlabs/sky-ai-accesspoint/lib/types/types';

const app = express();
app.use(cors());
app.use(bodyParser.json());
const port = process.env.PORT || 3000;

// Natural function without file upload support
const runNaturalFunction = async (
  req: Request,
  res: Response,
  balanceRunMain: BalanceRunMain,
  responseHandler: ResponseHandler
): Promise<void> => {
  try {
    const { prompt, accountNFT, userAuthPayload } = req.body;

    // Send progress update
    responseHandler.sendUpdate("Processing your request...");

    // Step 1: Use AI to parse and extract parameters from user request
    const completion = await balanceRunMain.callAIModel(`[
      {
        "role": "system",
        "content": "You are a helpful assistant that extracts parameters from user requests. Return only valid JSON with the required fields."
      },
      {
        "role": "user",
        "content": "${prompt}"
      }
    ]`);

    if (!completion.success) {
      responseHandler.sendError(completion.message, 500);
      return;
    }

    // Step 2: Parse AI response to get structured parameters
    let params;
    console.log("AI completion message:", completion.message);
    try {
      params = JSON.parse(completion.message || "");
    } catch (parseError) {
      responseHandler.sendError("Failed to parse AI response parameters", 500);
      return;
    }

    // Step 3: Process the extracted parameters
    responseHandler.sendUpdate("Processing extracted parameters...");
    
    // Example: Process based on extracted action
    let processedResult;
    if (params.action === 'analyze') {
      processedResult = `Analyzing: ${params.domain || 'unknown domain'}`;
    } else if (params.action === 'generate') {
      processedResult = `Generating content for: ${params.keyword || 'unknown keyword'}`;
    } else {
      processedResult = `Processed: ${prompt}`;
    }
    
    // Calculate cost (example: 0.01 tokens per request)
    const cost = BigInt(0.01 * 1e12); // Convert to wei equivalent
    
    // Send final response
    responseHandler.sendFinalResponse({
      success: true,
      message: "Request completed successfully",
      data: {
        result: processedResult,
        extractedParams: params,
        timestamp: new Date().toISOString()
      }
    });

    // Add cost to user's balance
    await balanceRunMain.addCost(accountNFT, cost.toString());
    console.log(`Added cost: ${cost} for user: ${accountNFT.collectionID}_${accountNFT.nftID}`);

  } catch (error) {
    console.error("Error processing request:", error);
    responseHandler.sendError(
      error instanceof Error ? error.message : "Failed to process request",
      500
    );
  }
};

const setup = async () => {
  const skyNode: SkyMainNodeJS = await getSkyNode();
  const env = {
    JSON_RPC_PROVIDER: process.env.PROVIDER_RPC!,
    WALLET_PRIVATE_KEY: process.env.WALLET_PRIVATE_KEY!,
    SUBNET_ID: process.env.SUBNET_ID!,
    POSTGRES_URL: process.env.DATABASE_URL!,
    SERVER_COST_CONTRACT_ADDRESS: process.env.SERVER_COST_CONTRACT_ADDRESS!,
  };

  const balanceRunMain = await initAIAccessPoint(
    env,
    skyNode,
    app,
    runNaturalFunction,
    true, // Enable balance updates
    undefined, // No upload middleware (no file upload support)
    {
      // Optional: Pass custom auth service here
      // authService: new MyCustomAuthService(pool)
    }
  );

  if (!balanceRunMain.success) {
    console.error("Error initializing AI Access Point:", balanceRunMain);
    process.exit(1);
  }

  // Simple health check endpoint
  app.get('/health', (req: Request, res: Response) => {
    res.json({ 
      status: 'healthy', 
      uploadSupport: false,
      timestamp: new Date().toISOString()
    });
  });

  app.listen(port, () => {
    console.log(`Service is running on http://localhost:${port}`);
    console.log(`Health check: http://localhost:${port}/health`);
  });
};

setup().catch(console.error);
```

## 14. Custom Auth Service Implementation (Third-Party Auth)

### Example: Gmail Auth Service
```typescript
// src/services/GmailAuthService.ts
import { AuthService } from '@decloudlabs/sky-ai-accesspoint/lib/services/authService';
import { Pool } from 'pg';
import axios from 'axios';
import crypto from 'crypto';

export class GmailAuthService extends AuthService {
  constructor(pool: Pool) {
    super(pool);
  }

  async generateAuthLink(userAddress: string, nftId: string): Promise<string> {
    const state = crypto.randomBytes(32).toString('hex');
    const stateData = { userAddress, service: 'gmail', timestamp: Date.now(), nftId };
    
    // Store state for validation
    global.authStates = global.authStates || new Map();
    global.authStates.set(state, { ...stateData, createdAt: Date.now() });

    return `https://accounts.google.com/oauth/authorize?` +
      `client_id=${process.env.GOOGLE_CLIENT_ID}&` +
      `redirect_uri=${encodeURIComponent(process.env.AUTH_CALLBACK_URL!)}&` +
      `response_type=code&` +
      `scope=${encodeURIComponent('https://www.googleapis.com/auth/gmail.readonly')}&` +
      `state=${state}&` +
      `access_type=offline&` +
      `prompt=consent`;
  }

  async checkAuthStatus(userAddress: string, nftId: string): Promise<boolean> {
    try {
      const authData = await this.getAuth(userAddress, nftId);
      if (!authData) return false;

      // Check if token is expired
      if (authData.expires_at && Date.now() > authData.expires_at) {
        return false;
      }

      // Validate token
      const response = await axios.get('https://gmail.googleapis.com/gmail/v1/users/me/profile', {
        headers: { 'Authorization': `Bearer ${authData.access_token}` }
      });
      return response.status === 200;
    } catch (error) {
      return false;
    }
  }
}
```

### OAuth Callback Handler
```typescript
// src/routes/authRoutes.ts
import express, { Request, Response } from 'express';
import { getAuthService } from '@decloudlabs/sky-ai-accesspoint/lib/init';
import axios from 'axios';

const router = express.Router();

router.get('/callback', async (req: Request, res: Response) => {
  try {
    const { code, state, error } = req.query;
    
    if (error || !code || !state) {
      return res.status(400).json({ success: false, error: 'Invalid OAuth response' });
    }

    // Validate state
    global.authStates = global.authStates || new Map();
    const stateData = global.authStates.get(state as string);
    if (!stateData) {
      return res.status(400).json({ success: false, error: 'Invalid state' });
    }

    const { userAddress, nftId } = stateData;

    // Exchange code for tokens
    const tokenResponse = await axios.post('https://oauth2.googleapis.com/token', {
      client_id: process.env.GOOGLE_CLIENT_ID,
      client_secret: process.env.GOOGLE_CLIENT_SECRET,
      code,
      grant_type: 'authorization_code',
      redirect_uri: process.env.AUTH_CALLBACK_URL
    });

    // Get user profile
    const profileResponse = await axios.get('https://www.googleapis.com/oauth2/v2/userinfo', {
      headers: { 'Authorization': `Bearer ${tokenResponse.data.access_token}` }
    });

    // Save auth data
    const authData = {
      service: 'gmail',
      access_token: tokenResponse.data.access_token,
      refresh_token: tokenResponse.data.refresh_token,
      expires_at: tokenResponse.data.expires_in ? Date.now() + (tokenResponse.data.expires_in * 1000) : undefined,
      userAddress,
      profile: profileResponse.data,
      emailAddress: profileResponse.data.email,
      connectedAt: new Date().toISOString()
    };

    const authService = getAuthService();
    if (authService) {
      await authService.saveAuth(userAddress, nftId, authData);
    }

    // Clean up and redirect
    global.authStates.delete(state as string);
    res.redirect(`${process.env.FRONTEND_URL}/auth/success?service=gmail&userAddress=${userAddress}`);

  } catch (error) {
    console.error('OAuth callback error:', error);
    res.redirect(`${process.env.FRONTEND_URL}/auth/error`);
  }
});

export default router;
```

### Updated Main Initialization with Auth Service
```typescript
// src/index.ts (with auth support)
import dotenv from "dotenv";
dotenv.config();
import express, { Request, Response } from "express";
import SkyMainNodeJS from "@decloudlabs/skynet/lib/services/SkyMainNodeJS";
import { getSkyNode } from "./clients/skynet";
import { initAIAccessPoint, getAuthService } from "@decloudlabs/sky-ai-accesspoint/lib/init";
import { GmailAuthService } from "./services/GmailAuthService";
import authRoutes from "./routes/authRoutes";
import cors from "cors";
import bodyParser from "body-parser";
import { Pool } from "pg";
import BalanceRunMain from '@decloudlabs/sky-ai-accesspoint/lib/balanceRunMain';
import { ResponseHandler } from '@decloudlabs/sky-ai-accesspoint/lib/types/types';

const app = express();
app.use(cors());
app.use(bodyParser.json());
const port = process.env.PORT || 3000;

// Natural function with auth support
const runNaturalFunction = async (
  req: Request,
  res: Response,
  balanceRunMain: BalanceRunMain,
  responseHandler: ResponseHandler
): Promise<void> => {
  try {
    const { prompt, accountNFT, userAuthPayload } = req.body;
    const userAddress = userAuthPayload?.userAddress;
    const nftId = accountNFT?.nftID;

    // Check authentication
    const authService = getAuthService();
    if (authService) {
      const isAuthenticated = await authService.checkAuthStatus(userAddress, nftId);
      
      if (!isAuthenticated) {
        responseHandler.sendFinalResponse({
          success: true,
          message: "Authentication required. Please use the /auth-link endpoint.",
          requiresAuth: true,
          userAddress: userAddress
        });
        return;
      }

      const authData = await authService.getAuth(userAddress, nftId);
      console.log('User authenticated:', authData?.emailAddress);
    }

    responseHandler.sendUpdate("Processing authenticated request...");
    
    const processedResult = `Processed: ${prompt}`;
    const cost = BigInt(0.01 * 1e12);
    
    responseHandler.sendFinalResponse({
      success: true,
      message: "Request completed successfully",
      data: { result: processedResult, timestamp: new Date().toISOString() }
    });

    await balanceRunMain.addCost(accountNFT, cost.toString());

  } catch (error) {
    responseHandler.sendError(error instanceof Error ? error.message : "Failed to process request", 500);
  }
};

const setup = async () => {
  const skyNode: SkyMainNodeJS = await getSkyNode();
  const env = {
    JSON_RPC_PROVIDER: process.env.PROVIDER_RPC!,
    WALLET_PRIVATE_KEY: process.env.WALLET_PRIVATE_KEY!,
    SUBNET_ID: process.env.SUBNET_ID!,
    POSTGRES_URL: process.env.DATABASE_URL!,
    SERVER_COST_CONTRACT_ADDRESS: process.env.SERVER_COST_CONTRACT_ADDRESS!,
  };

  // Create custom auth service
  const pool = new Pool({ connectionString: env.POSTGRES_URL });
  const gmailAuthService = new GmailAuthService(pool);

  const balanceRunMain = await initAIAccessPoint(
    env,
    skyNode,
    app,
    runNaturalFunction,
    true,
    undefined,
    { authService: gmailAuthService }
  );

  if (!balanceRunMain.success) {
    console.error("Error initializing AI Access Point:", balanceRunMain);
    process.exit(1);
  }

  // Add auth routes
  app.use('/auth', authRoutes);

  app.get('/health', (req: Request, res: Response) => {
    res.json({ status: 'healthy', authSupport: true, timestamp: new Date().toISOString() });
  });

  app.listen(port, () => {
    console.log(`Service running on http://localhost:${port}`);
    console.log(`Auth callback: http://localhost:${port}/auth/callback`);
  });
};

setup().catch(console.error);
```

### Required Environment Variables for Auth
```env
# OAuth Configuration
GOOGLE_CLIENT_ID=<your-google-client-id>
GOOGLE_CLIENT_SECRET=<your-google-client-secret>
AUTH_CALLBACK_URL=http://localhost:3000/auth/callback
FRONTEND_URL=http://localhost:3000
JWT_SECRET=<your-jwt-secret>
```

## 15. Test Scripts (HTTP REST Only)

### Test Script for Upload Support (FormData)
```typescript
// test/upload.test.ts
import axios from 'axios';
import FormData from 'form-data';
import fs from 'fs';
import { getSkyNode } from "../src/clients/skynet";
import SkyMainNodeJS from "@decloudlabs/skynet/lib/services/SkyMainNodeJS";

async function testUploadRequest() {
  try {
    const skyNode: SkyMainNodeJS = await getSkyNode();
    const signature = await skyNode.appManager.getUrsulaAuth();

    console.log("Testing upload request with FormData...");

    // Create form data
    const formData = new FormData();
    
    // Add files
    formData.append('files', fs.createReadStream('./test-file.txt'), {
      filename: 'test-file.txt',
      contentType: 'text/plain'
    });
    
    // Add JSON data as strings
    formData.append('prompt', JSON.stringify("Analyze the uploaded file"));
    formData.append('userAuthPayload', JSON.stringify(signature.data));
    formData.append('accountNFT', JSON.stringify({
      "collectionID": "0",
      "nftID": "53"
    }));

    // Make request
    const response = await axios.post('http://localhost:3000/natural-request', formData, {
      headers: {
        ...formData.getHeaders(),
        'Content-Type': 'multipart/form-data'
      }
    });

    console.log("✅ Upload test passed");
    console.log("Response:", response.data);
    return true;
  } catch (error) {
    console.error("❌ Upload test failed:", error.response?.data || error.message);
    return false;
  }
}

async function testUploadStreaming() {
  try {
    const skyNode: SkyMainNodeJS = await getSkyNode();
    const signature = await skyNode.appManager.getUrsulaAuth();

    console.log("Testing upload with streaming...");

    const formData = new FormData();
    formData.append('files', fs.createReadStream('./test-file.txt'), {
      filename: 'test-file.txt',
      contentType: 'text/plain'
    });
    formData.append('prompt', JSON.stringify("Streaming test with file"));
    formData.append('userAuthPayload', JSON.stringify(signature.data));
    formData.append('accountNFT', JSON.stringify({
      "collectionID": "0",
      "nftID": "53"
    }));

    const response = await axios.post('http://localhost:3000/natural-request?stream=true', formData, {
      headers: {
        ...formData.getHeaders(),
        'Content-Type': 'multipart/form-data'
      },
      responseType: 'stream'
    });

    if (response.status === 200 && response.headers['content-type']?.includes('text/event-stream')) {
      console.log("✅ Upload streaming test passed");
      
      response.data.on('data', (chunk: Buffer) => {
        const lines = chunk.toString().split('\n');
        lines.forEach(line => {
          if (line.startsWith('data: ')) {
            const data = JSON.parse(line.slice(6));
            console.log('Stream data:', data);
          }
        });
      });
      
      return true;
    } else {
      console.log("❌ Upload streaming test failed");
      return false;
    }
  } catch (error) {
    console.error("❌ Upload streaming test error:", error.response?.data || error.message);
    return false;
  }
}

// Run upload tests
async function runUploadTests() {
  console.log("🚀 Starting upload tests...\n");
  
  const results = {
    upload: await testUploadRequest(),
    streaming: await testUploadStreaming()
  };

  console.log("\n📊 Upload Test Results:");
  console.log("Upload Request:", results.upload ? "✅ PASS" : "❌ FAIL");
  console.log("Upload Streaming:", results.streaming ? "✅ PASS" : "❌ FAIL");

  const allPassed = Object.values(results).every(result => result);
  console.log("\n🎯 Upload Tests Result:", allPassed ? "✅ ALL TESTS PASSED" : "❌ SOME TESTS FAILED");
  
  return allPassed;
}

// Run tests if this file is executed directly
if (require.main === module) {
  runUploadTests().then(success => process.exit(success ? 0 : 1));
}

export { runUploadTests };
```

### Test Script for AgentCollection Verification
```typescript
// test/agent-collection.test.ts
import axios from 'axios';
import { getSkyNode } from "../src/clients/skynet";
import SkyMainNodeJS from "@decloudlabs/skynet/lib/services/SkyMainNodeJS";

async function testAgentCollectionVerification() {
  try {
    const skyNode: SkyMainNodeJS = await getSkyNode();
    const signature = await skyNode.appManager.getUrsulaAuth();

    console.log("🤖 Testing AgentCollection verification...");

    // Test 1: AgentCollection with specific agent ID
    const response1 = await axios.post('http://localhost:3000/natural-request', {
      prompt: "Analyze my agent's performance",
      userAuthPayload: signature.data,
      accountNFT: {
        "collectionID": "0",
        "nftID": "53"
      },
      agentCollection: {
        agentAddress: "0xabcdef1234567890",
        agentID: "123"
      }
    }, {
      headers: {
        'Content-Type': 'application/json'
      }
    });

    if (response1.status === 200 && response1.data.success) {
      console.log("✅ AgentCollection with agent ID test passed");
    } else {
      console.log("❌ AgentCollection with agent ID test failed:", response1.data);
      return false;
    }

    // Test 2: AgentCollection without agent ID (admin role check)
    const response2 = await axios.post('http://localhost:3000/natural-request', {
      prompt: "Get all my agents' status",
      userAuthPayload: signature.data,
      accountNFT: {
        "collectionID": "0",
        "nftID": "53"
      },
      agentCollection: {
        agentAddress: "0xabcdef1234567890"
        // No agentID - will check admin role
      }
    }, {
      headers: {
        'Content-Type': 'application/json'
      }
    });

    if (response2.status === 200 && response2.data.success) {
      console.log("✅ AgentCollection admin role test passed");
    } else {
      console.log("❌ AgentCollection admin role test failed:", response2.data);
      return false;
    }

    // Test 3: Invalid AgentCollection (should fail)
    try {
      const response3 = await axios.post('http://localhost:3000/natural-request', {
        prompt: "Test with invalid agent",
        userAuthPayload: signature.data,
        accountNFT: {
          "collectionID": "0",
          "nftID": "53"
        },
        agentCollection: {
          agentAddress: "0xinvalidaddress",
          agentID: "999"
        }
      });

      if (response3.status === 401) {
        console.log("✅ Invalid AgentCollection test passed (correctly rejected)");
      } else {
        console.log("❌ Invalid AgentCollection test failed (should have been rejected)");
        return false;
      }
    } catch (error) {
      if (error.response?.status === 401) {
        console.log("✅ Invalid AgentCollection test passed (correctly rejected)");
      } else {
        console.log("❌ Invalid AgentCollection test error:", error.response?.data || error.message);
        return false;
      }
    }

    console.log("✅ All AgentCollection verification tests passed");
    return true;
  } catch (error) {
    console.error("❌ AgentCollection verification test error:", error.response?.data || error.message);
    return false;
  }
}

// Run AgentCollection tests
async function runAgentCollectionTests() {
  console.log("🤖 Starting AgentCollection verification tests...\n");
  
  const result = await testAgentCollectionVerification();
  
  console.log("\n📊 AgentCollection Test Results:");
  console.log("AgentCollection Verification:", result ? "✅ PASS" : "❌ FAIL");
  
  console.log("\n🎯 AgentCollection Tests Result:", result ? "✅ ALL TESTS PASSED" : "❌ TESTS FAILED");
  
  return result;
}

// Run tests if this file is executed directly
if (require.main === module) {
  runAgentCollectionTests().then(success => process.exit(success ? 0 : 1));
}

export { runAgentCollectionTests };
```

### Test Script for Non-Upload Support (JSON)
```typescript
// test/non-upload.test.ts
import axios from 'axios';
import { getSkyNode } from "../src/clients/skynet";
import SkyMainNodeJS from "@decloudlabs/skynet/lib/services/SkyMainNodeJS";

async function testNonUploadRequest() {
  try {
    const skyNode: SkyMainNodeJS = await getSkyNode();
    const signature = await skyNode.appManager.getUrsulaAuth();

    console.log("Testing non-upload request...");

    const response = await axios.post('http://localhost:3000/natural-request', {
      prompt: "Analyze the domain example.com",
      userAuthPayload: signature.data,
      accountNFT: {
        "collectionID": "0",
        "nftID": "53"
      }
    }, {
      headers: {
        'Content-Type': 'application/json'
      }
    });

    console.log("✅ Non-upload test passed");
    console.log("Response:", response.data);
    return true;
  } catch (error) {
    console.error("❌ Non-upload test failed:", error.response?.data || error.message);
    return false;
  }
}

async function testNonUploadStreaming() {
  try {
    const skyNode: SkyMainNodeJS = await getSkyNode();
    const signature = await skyNode.appManager.getUrsulaAuth();

    console.log("Testing non-upload streaming...");

    const response = await axios.post('http://localhost:3000/natural-request?stream=true', {
      prompt: "Generate a long response with streaming",
      userAuthPayload: signature.data,
      accountNFT: {
        "collectionID": "0",
        "nftID": "53"
      }
    }, {
      responseType: 'stream',
      headers: {
        'Content-Type': 'application/json'
      }
    });

    if (response.status === 200 && response.headers['content-type']?.includes('text/event-stream')) {
      console.log("✅ Non-upload streaming test passed");
      
      response.data.on('data', (chunk: Buffer) => {
        const lines = chunk.toString().split('\n');
        lines.forEach(line => {
          if (line.startsWith('data: ')) {
            const data = JSON.parse(line.slice(6));
            console.log('Stream data:', data);
          }
        });
      });
      
      return true;
    } else {
      console.log("❌ Non-upload streaming test failed");
      return false;
    }
  } catch (error) {
    console.error("❌ Non-upload streaming test error:", error.response?.data || error.message);
    return false;
  }
}

async function testAuthentication() {
  try {
    console.log("Testing authentication...");

    const response = await axios.post('http://localhost:3000/natural-request', {
      prompt: "Test request without auth",
      accountNFT: {
        "collectionID": "0",
        "nftID": "53"
      }
    });

    if (response.status === 401) {
      console.log("✅ Authentication test passed (correctly rejected)");
      return true;
    } else {
      console.log("❌ Authentication test failed (should have been rejected)");
      return false;
    }
  } catch (error) {
    if (error.response?.status === 401) {
      console.log("✅ Authentication test passed (correctly rejected)");
      return true;
    } else {
      console.error("❌ Authentication test error:", error.response?.data || error.message);
      return false;
    }
  }
}

// Run non-upload tests
async function runNonUploadTests() {
  console.log("🚀 Starting non-upload tests...\n");
  
  const results = {
    request: await testNonUploadRequest(),
    streaming: await testNonUploadStreaming(),
    auth: await testAuthentication()
  };

  console.log("\n📊 Non-Upload Test Results:");
  console.log("JSON Request:", results.request ? "✅ PASS" : "❌ FAIL");
  console.log("JSON Streaming:", results.streaming ? "✅ PASS" : "❌ FAIL");
  console.log("Authentication:", results.auth ? "✅ PASS" : "❌ FAIL");

  const allPassed = Object.values(results).every(result => result);
  console.log("\n🎯 Non-Upload Tests Result:", allPassed ? "✅ ALL TESTS PASSED" : "❌ SOME TESTS FAILED");
  
  return allPassed;
}

// Run tests if this file is executed directly
if (require.main === module) {
  runNonUploadTests().then(success => process.exit(success ? 0 : 1));
}

export { runNonUploadTests };
```

### Test Script for Auth Endpoints
```typescript
// test/auth.test.ts
import axios from 'axios';
import { getSkyNode } from "../src/clients/skynet";
import SkyMainNodeJS from "@decloudlabs/skynet/lib/services/SkyMainNodeJS";

async function testAuthLink() {
  try {
    const skyNode = await getSkyNode();
    const signature = await skyNode.appManager.getUrsulaAuth();
    
    // ✅ CORRECT: Send as JSON strings for auth endpoints
    const response = await axios.post('http://localhost:3000/auth-link', {
      userAuthPayload: JSON.stringify(signature.data), // Convert to JSON string
      accountNFT: JSON.stringify({                     // Convert to JSON string
        "collectionID": "0",
        "nftID": "53"
      })
    });
    
    if (response.status === 200 && response.data.success) {
      console.log("✅ Auth link test passed");
      return true;
    } else {
      console.log("❌ Auth link test failed");
      return false;
    }
  } catch (error) {
    console.log("❌ Auth link test error:", error.message);
    return false;
  }
}

async function testAuthStatus() {
  try {
    const skyNode = await getSkyNode();
    const signature = await skyNode.appManager.getUrsulaAuth();

    console.log("Testing auth status...");

    // ✅ CORRECT: Send as JSON strings (not objects)
    const response = await axios.post('http://localhost:3000/auth-status', {
      userAuthPayload: JSON.stringify(signature.data), // Convert to JSON string
      accountNFT: JSON.stringify({                     // Convert to JSON string
        "collectionID": "0",
        "nftID": "53"
      })
    }, {
      headers: {
        'Content-Type': 'application/json'
      }
    });

    if (response.status === 200 && response.data.success) {
      console.log("✅ Auth status test passed");
      console.log("Auth status:", response.data.data);
      return true;
    } else {
      console.log("❌ Auth status test failed:", response.data);
      return false;
    }
  } catch (error) {
    console.error("❌ Auth status test error:", error.response?.data || error.message);
    return false;
  }
}

async function testOAuthCallback() {
  try {
    console.log("Testing OAuth callback...");

    const response = await axios.get('http://localhost:3000/auth/callback?code=test-code&state=test-state', {
      maxRedirects: 0,
      validateStatus: (status) => status < 400
    });

    if (response.status === 302 || response.status === 200) {
      console.log("✅ OAuth callback test passed");
      return true;
    } else {
      console.log("❌ OAuth callback test failed:", response.status);
      return false;
    }
  } catch (error) {
    if (error.response?.status === 302) {
      console.log("✅ OAuth callback test passed (redirect)");
      return true;
    } else {
      console.error("❌ OAuth callback test error:", error.response?.data || error.message);
      return false;
    }
  }
}

async function testAuthValidation() {
  try {
    console.log("Testing auth validation...");

    const response = await axios.post('http://localhost:3000/auth-link', {});

    if (response.status === 400) {
      console.log("✅ Auth validation test passed (correctly rejected)");
      return true;
    } else {
      console.log("❌ Auth validation test failed (should have been rejected)");
      return false;
    }
  } catch (error) {
    if (error.response?.status === 400) {
      console.log("✅ Auth validation test passed (correctly rejected)");
      return true;
    } else {
      console.error("❌ Auth validation test error:", error.response?.data || error.message);
      return false;
    }
  }
}

// Run auth tests
async function runAuthTests() {
  console.log("🔐 Starting auth tests...\n");
  
  const results = {
    linkGeneration: await testAuthLink(),
    status: await testAuthStatus(),
    callback: await testOAuthCallback(),
    validation: await testAuthValidation()
  };

  console.log("\n📊 Auth Test Results:");
  console.log("Link Generation:", results.linkGeneration ? "✅ PASS" : "❌ FAIL");
  console.log("Auth Status:", results.status ? "✅ PASS" : "❌ FAIL");
  console.log("OAuth Callback:", results.callback ? "✅ PASS" : "❌ FAIL");
  console.log("Validation:", results.validation ? "✅ PASS" : "❌ FAIL");

  const allPassed = Object.values(results).every(result => result);
  console.log("\n🎯 Auth Tests Result:", allPassed ? "✅ ALL AUTH TESTS PASSED" : "❌ SOME AUTH TESTS FAILED");
  
  return allPassed;
}

// Run tests if this file is executed directly
if (require.main === module) {
  runAuthTests().then(success => process.exit(success ? 0 : 1));
}

export { runAuthTests };
```

### Integration Test Script
```typescript
// test/integration.test.ts
import axios from 'axios';
import FormData from 'form-data';
import fs from 'fs';
import { getSkyNode } from "../src/clients/skynet";
import SkyMainNodeJS from "@decloudlabs/skynet/lib/services/SkyMainNodeJS";

async function testCompleteWorkflow() {
  try {
    const skyNode: SkyMainNodeJS = await getSkyNode();
    const signature = await skyNode.appManager.getUrsulaAuth();

    console.log("🔄 Testing complete workflow...");

    // Step 1: Test auth link generation (JSON strings required)
    const authResponse = await axios.post('http://localhost:3000/auth-link', {
      userAuthPayload: JSON.stringify(signature.data), // Convert to JSON string
      accountNFT: JSON.stringify({                     // Convert to JSON string
        "collectionID": "0",
        "nftID": "53"
      })
    });

    if (!authResponse.data.success) {
      console.log("❌ Auth link generation failed");
      return false;
    }

    // Step 2: Test natural function via JSON (objects allowed for natural-request)
    const jsonResponse = await axios.post('http://localhost:3000/natural-request', {
      prompt: "Integration test request",
      userAuthPayload: signature.data,  // Objects allowed for natural-request
      accountNFT: {                     // Objects allowed for natural-request
        "collectionID": "0",
        "nftID": "53"
      }
    });

    if (!jsonResponse.data.success) {
      console.log("❌ JSON request failed");
      return false;
    }

    // Step 3: Test natural function via FormData
    const formData = new FormData();
    formData.append('files', fs.createReadStream('./test-file.txt'), {
      filename: 'test-file.txt',
      contentType: 'text/plain'
    });
    formData.append('prompt', JSON.stringify("Integration test with file"));
    formData.append('userAuthPayload', JSON.stringify(signature.data));
    formData.append('accountNFT', JSON.stringify({
      "collectionID": "0",
      "nftID": "53"
    }));

    const uploadResponse = await axios.post('http://localhost:3000/natural-request', formData, {
      headers: {
        ...formData.getHeaders(),
        'Content-Type': 'multipart/form-data'
      }
    });

    if (!uploadResponse.data.success) {
      console.log("❌ Upload request failed");
      return false;
    }

    // Step 4: Test streaming
    const streamingResponse = await axios.post('http://localhost:3000/natural-request?stream=true', {
      prompt: "Streaming integration test",
      userAuthPayload: signature.data,  // Objects allowed for natural-request
      accountNFT: {                     // Objects allowed for natural-request
        "collectionID": "0",
        "nftID": "53"
      }
    }, {
      responseType: 'stream'
    });

    if (streamingResponse.status === 200 && streamingResponse.headers['content-type']?.includes('text/event-stream')) {
      console.log("✅ Streaming test passed");
    } else {
      console.log("❌ Streaming test failed");
      return false;
    }

    console.log("✅ Complete workflow test passed");
    return true;
  } catch (error) {
    console.error("❌ Integration test error:", error.response?.data || error.message);
    return false;
  }
}

// Run integration tests
async function runIntegrationTests() {
  console.log("🔗 Starting integration tests...\n");
  
  const workflowResult = await testCompleteWorkflow();
  
  console.log("\n📊 Integration Test Results:");
  console.log("Complete Workflow:", workflowResult ? "✅ PASS" : "❌ FAIL");
  
  console.log("\n🎯 Integration Tests Result:", workflowResult ? "✅ INTEGRATION TESTS PASSED" : "❌ INTEGRATION TESTS FAILED");
  
  return workflowResult;
}

// Run tests if this file is executed directly
if (require.main === module) {
  runIntegrationTests().then(success => process.exit(success ? 0 : 1));
}

export { runIntegrationTests };
```

### Master Test Runner
```typescript
// test/run-all-tests.ts
import { runUploadTests } from './upload.test';
import { runNonUploadTests } from './non-upload.test';
import { runAuthTests } from './auth.test';
import { runIntegrationTests } from './integration.test';
import { runAgentCollectionTests } from './agent-collection.test';

async function runAllTests() {
  console.log("🚀 Starting all tests...\n");
  
  const results = {
    upload: await runUploadTests(),
    nonUpload: await runNonUploadTests(),
    auth: await runAuthTests(),
    integration: await runIntegrationTests(),
    agentCollection: await runAgentCollectionTests()
  };

  console.log("\n📊 Overall Test Results:");
  console.log("Upload Tests:", results.upload ? "✅ PASS" : "❌ FAIL");
  console.log("Non-Upload Tests:", results.nonUpload ? "✅ PASS" : "❌ FAIL");
  console.log("Auth Tests:", results.auth ? "✅ PASS" : "❌ FAIL");
  console.log("Integration Tests:", results.integration ? "✅ PASS" : "❌ FAIL");
  console.log("AgentCollection Tests:", results.agentCollection ? "✅ PASS" : "❌ FAIL");

  const allPassed = Object.values(results).every(result => result);
  console.log("\n🎯 Overall Result:", allPassed ? "✅ ALL TESTS PASSED" : "❌ SOME TESTS FAILED");
  
  process.exit(allPassed ? 0 : 1);
}

// Run all tests
runAllTests();
```

### Test Setup Instructions
```bash
# Create test file
echo "This is a test file for upload testing" > test-file.txt

# Run individual test suites
npx ts-node test/upload.test.ts
npx ts-node test/non-upload.test.ts
npx ts-node test/auth.test.ts
npx ts-node test/integration.test.ts

# Run all tests
npx ts-node test/run-all-tests.ts
```

### Manual Testing Commands
```bash
# Test JSON request (objects allowed for natural-request)
curl -X POST http://localhost:3000/natural-request \
  -H "Content-Type: application/json" \
  -d '{
    "prompt": "Test request",
    "userAuthPayload": {"userAddress": "0x1234567890abcdef"},
    "accountNFT": {"collectionID": "0", "nftID": "53"}
  }'

# Test auth link generation (JSON strings required)
curl -X POST http://localhost:3000/auth-link \
  -H "Content-Type: application/json" \
  -d '{
    "userAuthPayload": "{\"userAddress\":\"0x1234567890abcdef\",\"signature\":\"0x...\",\"message\":\"1713033600000\"}",
    "accountNFT": "{\"collectionID\":\"0\",\"nftID\":\"53\"}"
  }'

# Test auth status (JSON strings required)
curl -X POST http://localhost:3000/auth-status \
  -H "Content-Type: application/json" \
  -d '{
    "userAuthPayload": "{\"userAddress\":\"0x1234567890abcdef\",\"signature\":\"0x...\",\"message\":\"1713033600000\"}",
    "accountNFT": "{\"collectionID\":\"0\",\"nftID\":\"53\"}"
  }'
```

## 13. Testing Rules (Strict Requirements)

### **NO TESTING LIBRARIES ALLOWED**
- ❌ **NO Jest** - Do not use Jest testing framework
- ❌ **NO Mocha** - Do not use Mocha testing framework  
- ❌ **NO Chai** - Do not use Chai assertion library
- ❌ **NO Supertest** - Do not use Supertest for HTTP testing
- ❌ **NO Testing Libraries** - Do not use any testing libraries or frameworks
- ✅ **ONLY Plain TypeScript** - Use simple TypeScript files with direct HTTP calls
- ✅ **ONLY Axios/Fetch** - Use axios or fetch for HTTP requests
- ✅ **ONLY Console.log** - Use console.log for test output and assertions

### **Single Test Script Requirement**
- ✅ **ONE test file only** - Create a single `test.ts` file in the root directory
- ✅ **All functionality in one file** - Test auth, natural request, upload, streaming in one script
- ✅ **Simple pass/fail logic** - Use boolean returns and console.log for results
- ✅ **Direct HTTP calls** - Call endpoints directly on localhost
- ✅ **No test runners** - Execute with `npx ts-node test.ts`

### **Required Test Structure**
```typescript
// test.ts - Single test file for all functionality
import axios from 'axios';
import FormData from 'form-data';
import fs from 'fs';
import { getSkyNode } from "./src/clients/skynet";

// Test functions return boolean (true = pass, false = fail)
async function testAuthLink() {
  try {
    const skyNode = await getSkyNode();
    const signature = await skyNode.appManager.getUrsulaAuth();
    
    // ✅ CORRECT: Send as JSON strings for auth endpoints
    const response = await axios.post('http://localhost:3000/auth-link', {
      userAuthPayload: JSON.stringify(signature.data), // Convert to JSON string
      accountNFT: JSON.stringify({                     // Convert to JSON string
        "collectionID": "0",
        "nftID": "53"
      })
    });
    
    if (response.status === 200 && response.data.success && response.data.data?.link) {
      console.log("✅ Auth link test passed");
      console.log("Auth URL:", response.data.data.link);
      return true;
    } else {
      console.log("❌ Auth link test failed:", response.data);
      return false;
    }
  } catch (error) {
    console.log("❌ Auth link test error:", error.response?.data || error.message);
    return false;
  }
}

async function testNaturalRequest() {
  try {
    const skyNode = await getSkyNode();
    const signature = await skyNode.appManager.getUrsulaAuth();
    
    // ✅ CORRECT: Send as objects for natural-request endpoint
    const response = await axios.post('http://localhost:3000/natural-request', {
      prompt: "Test request - analyze example.com",
      userAuthPayload: signature.data,
      accountNFT: {
        "collectionID": "0",
        "nftID": "53"
      }
    });
    
    if (response.status === 200 && response.data.success) {
      console.log("✅ Natural request test passed");
      console.log("Response:", response.data.data);
      return true;
    } else {
      console.log("❌ Natural request test failed:", response.data);
      return false;
    }
  } catch (error) {
    console.log("❌ Natural request test error:", error.response?.data || error.message);
    return false;
  }
}

// Test file upload (if supported)
async function testUpload() {
  try {
    const skyNode = await getSkyNode();
    const signature = await skyNode.appManager.getUrsulaAuth();
    
    console.log("📁 Testing file upload...");
    
    // Create test file if it doesn't exist
    if (!fs.existsSync('./test-file.txt')) {
      fs.writeFileSync('./test-file.txt', 'This is a test file for upload testing');
    }
    
    const formData = new FormData();
    formData.append('files', fs.createReadStream('./test-file.txt'), {
      filename: 'test-file.txt',
      contentType: 'text/plain'
    });
    formData.append('prompt', JSON.stringify("Analyze the uploaded file"));
    formData.append('userAuthPayload', JSON.stringify(signature.data));
    formData.append('accountNFT', JSON.stringify({
      "collectionID": "0",
      "nftID": "53"
    }));

    const response = await axios.post('http://localhost:3000/natural-request', formData, {
      headers: {
        ...formData.getHeaders(),
        'Content-Type': 'multipart/form-data'
      }
    });
    
    if (response.status === 200 && response.data.success) {
      console.log("✅ Upload test passed");
      return true;
    } else {
      console.log("❌ Upload test failed:", response.data);
      return false;
    }
  } catch (error) {
    if (error.response?.status === 400 && error.response?.data?.message?.includes('upload')) {
      console.log("ℹ️ Upload not supported (expected for non-upload setup)");
      return true; // Not a failure if upload is not supported
    }
    console.log("❌ Upload test error:", error.response?.data || error.message);
    return false;
  }
}

// Test streaming
async function testStreaming() {
  try {
    const skyNode = await getSkyNode();
    const signature = await skyNode.appManager.getUrsulaAuth();
    
    console.log("📡 Testing streaming...");
    
    const response = await axios.post('http://localhost:3000/natural-request?stream=true', {
      prompt: "Generate a long response with streaming",
      userAuthPayload: signature.data,
      accountNFT: {
        "collectionID": "0",
        "nftID": "53"
      }
    }, {
      responseType: 'stream'
    });
    
    if (response.status === 200 && response.headers['content-type']?.includes('text/event-stream')) {
      console.log("✅ Streaming test passed");
      
      // Listen to stream data
      response.data.on('data', (chunk: Buffer) => {
        const lines = chunk.toString().split('\n');
        lines.forEach(line => {
          if (line.startsWith('data: ')) {
            try {
              const data = JSON.parse(line.slice(6));
              if (data.type === 'update') {
                console.log('📡 Stream update:', data.message);
              } else if (data.type === 'final') {
                console.log('📡 Stream final:', data.data);
              }
            } catch (e) {
              // Ignore parse errors for incomplete chunks
            }
          }
        });
      });
      
      return true;
    } else {
      console.log("❌ Streaming test failed");
      return false;
    }
  } catch (error) {
    console.log("❌ Streaming test error:", error.response?.data || error.message);
    return false;
  }
}

// Test health endpoint
async function testHealth() {
  try {
    console.log("🏥 Testing health endpoint...");
    
    const response = await axios.get('http://localhost:3000/health');
    
    if (response.status === 200 && response.data.status === 'healthy') {
      console.log("✅ Health test passed");
      console.log("Health status:", response.data);
      return true;
    } else {
      console.log("❌ Health test failed:", response.data);
      return false;
    }
  } catch (error) {
    console.log("❌ Health test error:", error.response?.data || error.message);
    return false;
  }
}

// Main test runner
async function runAllTests() {
  console.log("🚀 Starting comprehensive test suite...\n");
  
  const results = {
    health: await testHealth(),
    auth: await testAuthLink(),
    natural: await testNaturalRequest(),
    upload: await testUpload(),
    streaming: await testStreaming()
  };

  console.log("\n📊 Test Results:");
  console.log("Health Check:", results.health ? "✅ PASS" : "❌ FAIL");
  console.log("Auth Link:", results.auth ? "✅ PASS" : "❌ FAIL");
  console.log("Natural Request:", results.natural ? "✅ PASS" : "❌ FAIL");
  console.log("File Upload:", results.upload ? "✅ PASS" : "❌ FAIL");
  console.log("Streaming:", results.streaming ? "✅ PASS" : "❌ FAIL");

  const allPassed = Object.values(results).every(result => result);
  console.log("\n🎯 Overall Result:", allPassed ? "✅ ALL TESTS PASSED" : "❌ SOME TESTS FAILED");
  
  if (allPassed) {
    console.log("\n🎉 Your AI Access Point is working correctly!");
    console.log("✅ Ready for production deployment");
  } else {
    console.log("\n⚠️ Some tests failed. Please check your implementation.");
    console.log("🔧 Review the error messages above and fix any issues.");
  }
  
  process.exit(allPassed ? 0 : 1);
}

// Run tests if this file is executed directly
if (require.main === module) {
  runAllTests();
}

export { runAllTests };
```

## 17. Final Testing Rule: Build and Test After Setup

### **MANDATORY: Test Your Implementation**
After completing your AI Access Point setup, you **MUST** test it with the following steps:

### **Step 1: Build the Project**
```bash
# Build TypeScript to JavaScript
npm run build

# Verify build was successful
ls lib/
# Should show compiled JavaScript files
```

### **Step 2: Create Test File**
Create a single `test.ts` file in your project root:

```typescript
// test.ts - Single comprehensive test file
import axios from 'axios';
import FormData from 'form-data';
import fs from 'fs';
import { getSkyNode } from "./src/clients/skynet";

// Test functions return boolean (true = pass, false = fail)
async function testAuthLink() {
  try {
    const skyNode = await getSkyNode();
    const signature = await skyNode.appManager.getUrsulaAuth();
    
    console.log("🔐 Testing auth link generation...");
    
    const response = await axios.post('http://localhost:3000/auth-link', {
      userAuthPayload: JSON.stringify(signature.data),
      accountNFT: JSON.stringify({
        "collectionID": "0",
        "nftID": "53"
      })
    });
    
    if (response.status === 200 && response.data.success && response.data.data?.link) {
      console.log("✅ Auth link test passed");
      console.log("Auth URL:", response.data.data.link);
      return true;
    } else {
      console.log("❌ Auth link test failed:", response.data);
      return false;
    }
  } catch (error) {
    console.log("❌ Auth link test error:", error.response?.data || error.message);
    return false;
  }
}

// Test natural request (JSON objects allowed)
async function testNaturalRequest() {
  try {
    const skyNode = await getSkyNode();
    const signature = await skyNode.appManager.getUrsulaAuth();
    
    console.log("🤖 Testing natural request...");
    
    const response = await axios.post('http://localhost:3000/natural-request', {
      prompt: "Test request - analyze example.com",
      userAuthPayload: signature.data,
      accountNFT: {
        "collectionID": "0",
        "nftID": "53"
      }
    });
    
    if (response.status === 200 && response.data.success) {
      console.log("✅ Natural request test passed");
      console.log("Response:", response.data.data);
      return true;
    } else {
      console.log("❌ Natural request test failed:", response.data);
      return false;
    }
  } catch (error) {
    console.log("❌ Natural request test error:", error.response?.data || error.message);
    return false;
  }
}

// Test file upload (if supported)
async function testUpload() {
  try {
    const skyNode = await getSkyNode();
    const signature = await skyNode.appManager.getUrsulaAuth();
    
    console.log("📁 Testing file upload...");
    
    // Create test file if it doesn't exist
    if (!fs.existsSync('./test-file.txt')) {
      fs.writeFileSync('./test-file.txt', 'This is a test file for upload testing');
    }
    
    const formData = new FormData();
    formData.append('files', fs.createReadStream('./test-file.txt'), {
      filename: 'test-file.txt',
      contentType: 'text/plain'
    });
    formData.append('prompt', JSON.stringify("Analyze the uploaded file"));
    formData.append('userAuthPayload', JSON.stringify(signature.data));
    formData.append('accountNFT', JSON.stringify({
      "collectionID": "0",
      "nftID": "53"
    }));

    const response = await axios.post('http://localhost:3000/natural-request', formData, {
      headers: {
        ...formData.getHeaders(),
        'Content-Type': 'multipart/form-data'
      }
    });
    
    if (response.status === 200 && response.data.success) {
      console.log("✅ Upload test passed");
      return true;
    } else {
      console.log("❌ Upload test failed:", response.data);
      return false;
    }
  } catch (error) {
    if (error.response?.status === 400 && error.response?.data?.message?.includes('upload')) {
      console.log("ℹ️ Upload not supported (expected for non-upload setup)");
      return true; // Not a failure if upload is not supported
    }
    console.log("❌ Upload test error:", error.response?.data || error.message);
    return false;
  }
}

// Test streaming
async function testStreaming() {
  try {
    const skyNode = await getSkyNode();
    const signature = await skyNode.appManager.getUrsulaAuth();
    
    console.log("📡 Testing streaming...");
    
    const response = await axios.post('http://localhost:3000/natural-request?stream=true', {
      prompt: "Generate a long response with streaming",
      userAuthPayload: signature.data,
      accountNFT: {
        "collectionID": "0",
        "nftID": "53"
      }
    }, {
      responseType: 'stream'
    });
    
    if (response.status === 200 && response.headers['content-type']?.includes('text/event-stream')) {
      console.log("✅ Streaming test passed");
      
      // Listen to stream data
      response.data.on('data', (chunk: Buffer) => {
        const lines = chunk.toString().split('\n');
        lines.forEach(line => {
          if (line.startsWith('data: ')) {
            try {
              const data = JSON.parse(line.slice(6));
              if (data.type === 'update') {
                console.log('📡 Stream update:', data.message);
              } else if (data.type === 'final') {
                console.log('📡 Stream final:', data.data);
              }
            } catch (e) {
              // Ignore parse errors for incomplete chunks
            }
          }
        });
      });
      
      return true;
    } else {
      console.log("❌ Streaming test failed");
      return false;
    }
  } catch (error) {
    console.log("❌ Streaming test error:", error.response?.data || error.message);
    return false;
  }
}

// Test health endpoint
async function testHealth() {
  try {
    console.log("🏥 Testing health endpoint...");
    
    const response = await axios.get('http://localhost:3000/health');
    
    if (response.status === 200 && response.data.status === 'healthy') {
      console.log("✅ Health test passed");
      console.log("Health status:", response.data);
      return true;
    } else {
      console.log("❌ Health test failed:", response.data);
      return false;
    }
  } catch (error) {
    console.log("❌ Health test error:", error.response?.data || error.message);
    return false;
  }
}

// Main test runner
async function runAllTests() {
  console.log("🚀 Starting comprehensive test suite...\n");
  
  const results = {
    health: await testHealth(),
    auth: await testAuthLink(),
    natural: await testNaturalRequest(),
    upload: await testUpload(),
    streaming: await testStreaming()
  };

  console.log("\n📊 Test Results:");
  console.log("Health Check:", results.health ? "✅ PASS" : "❌ FAIL");
  console.log("Auth Link:", results.auth ? "✅ PASS" : "❌ FAIL");
  console.log("Natural Request:", results.natural ? "✅ PASS" : "❌ FAIL");
  console.log("File Upload:", results.upload ? "✅ PASS" : "❌ FAIL");
  console.log("Streaming:", results.streaming ? "✅ PASS" : "❌ FAIL");

  const allPassed = Object.values(results).every(result => result);
  console.log("\n🎯 Overall Result:", allPassed ? "✅ ALL TESTS PASSED" : "❌ SOME TESTS FAILED");
  
  if (allPassed) {
    console.log("\n🎉 Your AI Access Point is working correctly!");
    console.log("✅ Ready for production deployment");
  } else {
    console.log("\n⚠️ Some tests failed. Please check your implementation.");
    console.log("🔧 Review the error messages above and fix any issues.");
  }
  
  process.exit(allPassed ? 0 : 1);
}

// Run tests if this file is executed directly
if (require.main === module) {
  runAllTests();
}

export { runAllTests };
```

### **Step 3: Install Required Dependencies**
```bash
# Install test dependencies
npm install axios form-data

# For TypeScript testing
npm install --save-dev ts-node @types/node
```

### **Step 4: Start Your Server**
```bash
# Start your server in one terminal
npm run dev
# or
npm start
```

### **Step 5: Run the Test Script**
```bash
# In another terminal, run the test
npx ts-node test.ts
```

### **Expected Test Output**
```
🚀 Starting comprehensive test suite...

🏥 Testing health endpoint...
✅ Health test passed
Health status: { status: 'healthy', timestamp: '2024-01-01T00:00:00.000Z' }

🔐 Testing auth link generation...
✅ Auth link test passed
Auth URL: https://oauth.provider.com/auth?client_id=...

🤖 Testing natural request...
✅ Natural request test passed
Response: { result: 'Analyzing: example.com', extractedParams: {...} }

📁 Testing file upload...
✅ Upload test passed

🤖 Testing AgentCollection verification...
✅ AgentCollection test passed

📡 Testing streaming...
✅ Streaming test passed
📡 Stream update: Processing your request...
📡 Stream final: { result: 'Generated content...' }

📊 Test Results:
Health Check: ✅ PASS
Auth Link: ✅ PASS
Natural Request: ✅ PASS
File Upload: ✅ PASS
AgentCollection: ✅ PASS
Streaming: ✅ PASS

🎯 Overall Result: ✅ ALL TESTS PASSED
```

### **Step 6: Verify Build Output**
```bash
# Check that the build was successful
ls lib/
# Should show:
# - index.js
# - init.js
# - services/
# - types/
# - middleware/
# - utils.js
# etc.

# Test the built version
node lib/init.js
```

### **Troubleshooting Common Issues**

#### **❌ Build Errors**
```bash
# If TypeScript compilation fails
npm run build
# Check for:
# - Missing imports
# - Type errors
# - Syntax errors
```

#### **❌ Test Connection Errors**
```bash
# If tests fail with connection errors
# 1. Ensure server is running on correct port
# 2. Check environment variables
# 3. Verify database connection
# 4. Check firewall/network settings
```

#### **❌ Auth Test Failures**
```bash
# If auth tests fail
# 1. Check environment variables (TWITTER_CLIENT_ID, etc.)
# 2. Verify database table creation
# 3. Check auth service implementation
# 4. Ensure OAuth callback URL is correct
```

#### **❌ Natural Request Failures**
```bash
# If natural request tests fail
# 1. Check AI model configuration
# 2. Verify balance system setup
# 3. Check API key validation
# 4. Ensure proper error handling
```

### **Final Checklist**
- ✅ **Build successful** - `npm run build` completes without errors
- ✅ **Server starts** - `npm run dev` starts without errors
- ✅ **Health endpoint** - `GET /health` returns 200
- ✅ **Auth link generation** - `POST /auth-link` returns valid URL
- ✅ **Natural request** - `POST /natural-request` processes requests
- ✅ **File upload** - `POST /natural-request` with FormData works (if supported)
- ✅ **AgentCollection verification** - `POST /natural-request` with agentCollection verifies ownership
- ✅ **Streaming** - `POST /natural-request?stream=true` returns SSE
- ✅ **All tests pass** - `npx ts-node test.ts` shows all ✅ PASS

### **Next Steps After Successful Testing**
1. **Deploy to production** environment
2. **Set up monitoring** and logging
3. **Configure SSL/TLS** certificates
4. **Set up CI/CD** pipeline
5. **Document API** endpoints
6. **Monitor performance** and usage

**Remember:** This comprehensive test ensures your AI Access Point is fully functional and ready for real-world use!

## 18. REST API Endpoint Rules: Use Only SDK-Provided Endpoints

### **MANDATORY: Use Only SDK-Provided Endpoints**
Your AI Access Point **MUST** use only the REST API endpoints provided by the SDK. Do not create custom endpoints for different types of requests.

### **✅ ALLOWED Endpoints (SDK-Provided Only)**
The SDK automatically creates these endpoints during initialization:

1. **`POST /natural-request`** - Main endpoint for all AI processing
2. **`POST /auth-link`** - OAuth authentication link generation
3. **`POST /auth-status`** - Check authentication status
4. **`GET /health`** - Health check endpoint (optional)

### **❌ FORBIDDEN: Custom Endpoints**
Do NOT create any of these custom endpoints:
- ❌ `POST /twitter/analyze` - Custom Twitter endpoint
- ❌ `POST /gmail/read` - Custom Gmail endpoint
- ❌ `POST /analyze-domain` - Custom domain analysis endpoint
- ❌ `POST /generate-content` - Custom content generation endpoint
- ❌ Any other custom endpoints for specific services

### **✅ CORRECT: Single Endpoint Approach**
Use **ONLY** the `/natural-request` endpoint for all AI processing. Let the AI model decide which service to use based on the user's prompt.

### **User Request Format (Simplified)**
Users should only send these three fields:

```json
{
  "prompt": "Analyze the Twitter account @example and generate a report",
  "userAuthPayload": {
    "userAddress": "0x1234567890abcdef",
    "signature": "0x...",
    "message": "1713033600000"
  },
  "accountNFT": {
    "collectionID": "0",
    "nftID": "53"
  }
}
```

### **AI Model Decision Making**
The AI model in your `runNaturalFunction` should:

1. **Parse the prompt** to understand the user's intent
2. **Determine required service** (Twitter, Gmail, etc.)
3. **Check authentication** for the required service
4. **Execute the appropriate action** based on the prompt
5. **Return unified response** format

### **Example Implementation**
```typescript
// ✅ CORRECT: Single natural function that handles all requests
const runNaturalFunction = async (
  req: Request,
  res: Response,
  balanceRunMain: BalanceRunMain,
  responseHandler: ResponseHandler
): Promise<void> => {
  try {
    const { prompt, accountNFT, userAuthPayload } = req.body;
    const userAddress = userAuthPayload?.userAddress;
    const nftId = accountNFT?.nftID;

    responseHandler.sendUpdate("Analyzing your request...");

    // Step 1: Use AI to parse the prompt and determine required service
    const completion = await balanceRunMain.callAIModel(`[
      {
        "role": "system",
        "content": "You are an AI assistant that analyzes user requests and determines which service is needed. Return only valid JSON with the required fields."
      },
      {
        "role": "user",
        "content": "${prompt}"
      }
    ]`);

    if (!completion.success) {
      responseHandler.sendError(completion.message, 500);
      return;
    }

    // Step 2: Parse AI response to get service requirements
    let serviceRequirements;
    try {
      serviceRequirements = JSON.parse(completion.message || "");
    } catch (parseError) {
      responseHandler.sendError("Failed to parse service requirements", 500);
      return;
    }

    // Step 3: Check authentication for required service
    const authService = getAuthService();
    if (authService && serviceRequirements.requiresAuth) {
      const isAuthenticated = await authService.checkAuthStatus(userAddress, nftId);
      
      if (!isAuthenticated) {
        responseHandler.sendFinalResponse({
          success: true,
          message: "Authentication required. Please use the /auth-link endpoint.",
          requiresAuth: true,
          userAddress: userAddress,
          service: serviceRequirements.service
        });
        return;
      }
    }

    // Step 4: Execute the appropriate action based on service requirements
    responseHandler.sendUpdate(`Processing ${serviceRequirements.action}...`);
    
    let result;
    switch (serviceRequirements.service) {
      case 'twitter':
        result = await handleTwitterRequest(prompt, userAddress, nftId, serviceRequirements);
        break;
      case 'gmail':
        result = await handleGmailRequest(prompt, userAddress, nftId, serviceRequirements);
        break;
      case 'analysis':
        result = await handleAnalysisRequest(prompt, serviceRequirements);
        break;
      default:
        result = `Processed: ${prompt}`;
    }
    
    // Step 5: Send unified response
    responseHandler.sendFinalResponse({
      success: true,
      message: "Request completed successfully",
      data: {
        result: result,
        service: serviceRequirements.service,
        action: serviceRequirements.action,
        timestamp: new Date().toISOString()
      }
    });

    // Add cost to user's balance
    const cost = BigInt(0.01 * 1e12);
    await balanceRunMain.addCost(accountNFT, cost.toString());

  } catch (error) {
    console.error("Error processing request:", error);
    responseHandler.sendError(
      error instanceof Error ? error.message : "Failed to process request",
      500
    );
  }
};

// Helper functions for different services
async function handleTwitterRequest(prompt: string, userAddress: string, nftId: string, requirements: any) {
  const authService = getAuthService() as TwitterAuthService;
  const twitterClient = await authService?.getTwitterClient(userAddress, nftId);
  
  if (requirements.action === 'analyze') {
    // Analyze Twitter account
    return `Analyzed Twitter account: ${requirements.target}`;
  } else if (requirements.action === 'tweet') {
    // Post tweet
    return `Posted tweet: ${requirements.content}`;
  }
  return `Twitter action completed: ${requirements.action}`;
}

async function handleGmailRequest(prompt: string, userAddress: string, nftId: string, requirements: any) {
  const authService = getAuthService() as GmailAuthService;
  const gmailClient = await authService?.getGmailClient(userAddress, nftId);
  
  if (requirements.action === 'read') {
    // Read emails
    return `Read ${requirements.count || 10} emails`;
  } else if (requirements.action === 'send') {
    // Send email
    return `Sent email to: ${requirements.recipient}`;
  }
  return `Gmail action completed: ${requirements.action}`;
}

async function handleAnalysisRequest(prompt: string, requirements: any) {
  if (requirements.action === 'analyze') {
    return `Analyzed: ${requirements.target}`;
  } else if (requirements.action === 'generate') {
    return `Generated content for: ${requirements.keyword}`;
  }
  return `Analysis completed: ${requirements.action}`;
}
```

### **AI Model Response Format**
The AI model should return JSON in this format:

```json
{
  "service": "twitter|gmail|analysis|general",
  "action": "analyze|tweet|read|send|generate",
  "requiresAuth": true|false,
  "target": "specific target (e.g., @username, domain)",
  "parameters": {
    "count": 10,
    "keyword": "example",
    "content": "tweet content"
  }
}
```

### **Example AI Model Responses**

#### **Twitter Analysis Request**
```json
// User prompt: "Analyze the Twitter account @example and generate a report"
{
  "service": "twitter",
  "action": "analyze",
  "requiresAuth": true,
  "target": "@example",
  "parameters": {
    "reportType": "comprehensive"
  }
}
```

#### **Gmail Reading Request**
```json
// User prompt: "Read my last 5 emails from important contacts"
{
  "service": "gmail",
  "action": "read",
  "requiresAuth": true,
  "target": "emails",
  "parameters": {
    "count": 5,
    "filter": "important"
  }
}
```

#### **Domain Analysis Request**
```json
// User prompt: "Analyze the domain example.com for SEO"
{
  "service": "analysis",
  "action": "analyze",
  "requiresAuth": false,
  "target": "example.com",
  "parameters": {
    "type": "seo"
  }
}
```

### **Authentication Flow**
1. **User sends request** to `/natural-request`
2. **AI determines service** and auth requirements
3. **If auth required** → Return auth link via `/auth-link`
4. **If auth not required** → Process immediately
5. **If auth available** → Process with authenticated service

### **Response Format (Unified)**
All responses follow the same format regardless of service:

```json
{
  "success": true,
  "message": "Request completed successfully",
  "data": {
    "result": "Service-specific result",
    "service": "twitter|gmail|analysis",
    "action": "analyze|tweet|read|send|generate",
    "timestamp": "2024-01-01T00:00:00.000Z"
  }
}
```

### **Error Handling**
- **Authentication required**: Return auth link
- **Service not supported**: Return error message
- **Invalid prompt**: Return parsing error
- **Service error**: Return service-specific error

### **Benefits of Single Endpoint Approach**
1. **Simplified client integration** - Only one endpoint to call
2. **AI-driven service selection** - No need to know service APIs
3. **Unified authentication** - Single auth flow for all services
4. **Consistent response format** - Same structure for all responses
5. **Easy to extend** - Add new services without new endpoints

### **Testing the Single Endpoint**
```typescript
// Test different types of requests through single endpoint
async function testSingleEndpoint() {
  const skyNode = await getSkyNode();
  const signature = await skyNode.appManager.getUrsulaAuth();
  
  const testCases = [
    {
      name: "Twitter Analysis",
      prompt: "Analyze the Twitter account @example and generate a report"
    },
    {
      name: "Gmail Reading", 
      prompt: "Read my last 5 emails from important contacts"
    },
    {
      name: "Domain Analysis",
      prompt: "Analyze the domain example.com for SEO"
    },
    {
      name: "Content Generation",
      prompt: "Generate a blog post about AI trends"
    },
    {
      name: "Agent Analysis",
      prompt: "Analyze my agent's performance and suggest improvements",
      agentCollection: {
        agentAddress: "0xabcdef1234567890",
        agentID: "123"
      }
    }
  ];

  for (const testCase of testCases) {
    console.log(`Testing: ${testCase.name}`);
    
    const requestBody: any = {
      prompt: testCase.prompt,
      userAuthPayload: signature.data,
      accountNFT: {
        "collectionID": "0",
        "nftID": "53"
      }
    };

    // Add agentCollection if provided
    if (testCase.agentCollection) {
      requestBody.agentCollection = testCase.agentCollection;
    }
    
    const response = await axios.post('http://localhost:3000/natural-request', requestBody);

    console.log(`✅ ${testCase.name}:`, response.data.data.service);
  }
}
```

### **Summary of Rules**
1. **✅ Use ONLY** `/natural-request` for all AI processing
2. **✅ Let AI model decide** which service to use based on prompt
3. **✅ Unified authentication** through `/auth-link` and `/auth-status`
4. **❌ NO custom endpoints** for specific services
5. **✅ Single response format** for all services
6. **✅ AI-driven service selection** and parameter extraction

**Remember:** The user should only need to send a prompt, userAuthPayload, and accountNFT. The AI model handles everything else!
