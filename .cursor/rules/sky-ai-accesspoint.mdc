---
description: 
globs: 
alwaysApply: false
---
# Sky AI Access Point SDK Rules

## 1. **SDK Type Definitions and Interfaces**

```typescript
// Add these type definitions to understand SDK structure better

// Core SDK Types
interface UrsulaAuth {
  success: boolean;
  data: {
    userAddress: string;
    signature: string;
    message: string;
  };
}

interface AccountNFT {
  collectionID: string;
  nftID: string;
}

interface ResponseHandler {
  sendUpdate(message: string): void;
  sendError(message: string, statusCode?: number): void;
  sendFinalResponse(response: {
    success: boolean;
    message?: string;
    data?: any;
  }): void;
}

interface BalanceRunMain {
  callAIModel(messages: any[], userAuthPayload: any, accountNFT: AccountNFT): Promise<{
    success: boolean;
    message: string;
  }>;
  addCost(accountNFT: AccountNFT, cost: string): Promise<void>;
}

// Environment Configuration
interface SkyEnvConfig {
  JSON_RPC_PROVIDER: string;
  WALLET_PRIVATE_KEY: string;
  SUBNET_ID: string;
  POSTGRES_URL: string;
  SERVER_COST_CONTRACT_ADDRESS: string;
}
```

## 2. **SDK Function Signatures**

```typescript
// Core SDK Functions - Add these to understand expected parameters

// Authentication Function Type
type SendAuthLinkFunctionType = (
  req: Request,
  res: Response,
  balanceRunMain: BalanceRunMain,
  userAddress: string,
  provider?: string
) => Promise<{
  success: boolean;
  authUrl?: string;
  error?: string;
}>;

// Natural Function Type
type NaturalFunctionType = (
  req: Request,
  res: Response,
  balanceRunMain: BalanceRunMain,
  responseHandler: ResponseHandler
) => Promise<void>;

// SDK Initialization Functions
declare function initAIAccessPoint(
  env: SkyEnvConfig,
  skyNode: SkyMainNodeJS,
  app: Express.Application,
  naturalFunction: NaturalFunctionType,
  enableBalanceUpdates: boolean,
  uploadMiddleware?: any, // multer middleware or undefined
  options?: {
    sendAuthLinkFunction?: SendAuthLinkFunctionType;
  }
): Promise<{ success: boolean; balanceRunMain?: BalanceRunMain }>;
```

## 3. **Request/Response Patterns**

```typescript
// Standard Request Patterns for Sky AI Access Points

// 1. Natural Request (JSON)
interface NaturalRequestBody {
  prompt: string;
  accountNFT: AccountNFT;
  userAuthPayload: {
    userAddress: string;
    signature: string;
    message: string;
  };
}

// 2. Auth Link Request
interface AuthLinkRequestBody {
  userAddress: string;
  provider: string;
  accountNFT: AccountNFT;
  userAuthPayload: {
    userAddress: string;
    signature: string;
    message: string;
  };
}

// 3. Standard Response Format
interface StandardResponse {
  success: boolean;
  message?: string;
  data?: {
    result: any;
    extractedParams: any;
    timestamp: string;
    service: string;
  };
  error?: string;
}
```

## 4. **Common Error Handling Patterns**

```typescript
// Common SDK Error Patterns to Handle

const commonSDKErrors = {
  // Authentication Errors
  MISSING_AUTH: "Missing userAuthPayload or accountNFT",
  INVALID_JSON: "Invalid JSON format",
  AUTH_FAILED: "Authentication failed",
  
  // AI Model Errors
  AI_PARSE_ERROR: "Failed to parse AI response parameters",
  AI_CALL_FAILED: "AI model call failed",
  
  // Balance/Cost Errors
  INSUFFICIENT_BALANCE: "Insufficient balance",
  COST_CALCULATION_ERROR: "Cost calculation failed",
  
  // Network/Service Errors
  SERVICE_UNAVAILABLE: "Service temporarily unavailable",
  RATE_LIMIT_EXCEEDED: "Rate limit exceeded"
};

// Error handling helper
const handleSDKError = (error: any, responseHandler: ResponseHandler) => {
  if (error.message?.includes("authentication")) {
    responseHandler.sendError("Authentication required", 401);
  } else if (error.message?.includes("balance")) {
    responseHandler.sendError("Insufficient balance", 402);
  } else if (error.message?.includes("rate limit")) {
    responseHandler.sendError("Rate limit exceeded", 429);
  } else {
    responseHandler.sendError(error.message || "Internal server error", 500);
  }
};
```

## 5. **SDK Middleware Understanding**

```typescript
// SDK Middleware Patterns

// The SDK automatically adds these middlewares:
// 1. parseAuth - Parses authentication headers
// 2. protect - Validates NFT ownership and signatures
// 3. balanceCheck - Checks user balance before operations

// Request flow in Sky AI Access Point:
// 1. parseAuth middleware extracts authentication
// 2. protect middleware validates user ownership
// 3. balanceCheck ensures sufficient balance
// 4. Natural function executes
// 5. Cost is automatically deducted
// 6. Response is sent via ResponseHandler

// Standard headers expected by SDK:
interface SDKHeaders {
  'Content-Type': 'application/json';
  'x-api-key'?: string; // Optional API key
  'Authorization'?: string; // Optional bearer token
}
```

## 6. **Complete Environment Variables Documentation**

```typescript
// Complete Environment Variables for Sky AI Access Points

interface CompleteEnvConfig {
  // Required - Blockchain Configuration
  PROVIDER_RPC: string;           // JSON-RPC provider URL
  WALLET_PRIVATE_KEY: string;     // Wallet private key for transactions
  SUBNET_ID: string;             // Sky AI subnet ID
  
  // Required - Database
  DATABASE_URL: string;          // PostgreSQL connection string
  
  // Required - AI Service (choose one)
  OPENROUTER_API_KEY?: string;   // OpenRouter API key
  OPENAI_API_KEY?: string;       // OpenAI API key
  
  // Optional - Server Configuration
  PORT?: string;                 // Server port (default: 3000)
  SERVER_COST_CONTRACT_ADDRESS?: string; // Cost contract address
  
  // Service-specific (example for Twitter)
  TWITTER_API_KEY?: string;      // Service API key
  TWITTER_API_SECRET?: string;   // Service API secret
  TWITTER_BEARER_TOKEN?: string; // Service bearer token
  TWITTER_CALLBACK_URL?: string; // OAuth callback URL
  
  // Optional - Storage (can use placeholders)
  LIGHTHOUSE_API_KEY?: string;
  IPFS_PROJECT_ID?: string;
  IPFS_PROJECT_SECRET?: string;
  CLOUD_BUCKET_NAME?: string;
  CLOUD_ACCESS_KEY_ID?: string;
  CLOUD_SECRET_ACCESS_KEY?: string;
  CLOUD_REGION?: string;
}
```

## 7. **Standard Testing Patterns**

```typescript
// Standard Testing Patterns for Sky AI Access Points

// 1. Authentication Test
const testAuthentication = async () => {
  const skyNode = await getSkyNode();
  const signature = await skyNode.appManager.getUrsulaAuth();
  
  // Use signature.data for requests
  return {
    userAddress: signature.data.userAddress,
    userAuthPayload: signature.data,
    accountNFT: { collectionID: "0", nftID: "53" }
  };
};

// 2. Natural Request Test
const testNaturalRequest = async (authData: any) => {
  const response = await axios.post('http://localhost:3000/natural-request', {
    prompt: "Your request here",
    accountNFT: authData.accountNFT,
    userAuthPayload: authData.userAuthPayload
  }, {
    headers: { 'Content-Type': 'application/json' }
  });
  
  return response.data;
};

// 3. Auth Flow Test
const testAuthFlow = async (authData: any) => {
  const response = await axios.post('http://localhost:3000/auth-link', {
    userAddress: authData.userAddress,
    provider: 'service-name',
    accountNFT: authData.accountNFT,
    userAuthPayload: authData.userAuthPayload
  }, {
    headers: { 'Content-Type': 'application/json' }
  });
  
  return response.data;
};
```

## 8. **Common SDK Usage Patterns**

```typescript
// Standard Sky AI Access Point Implementation Patterns

// 1. Basic Setup Pattern (No Upload)
const setupBasicAccessPoint = async () => {
  const skyNode = await getSkyNode();
  const env = {
    JSON_RPC_PROVIDER: process.env.PROVIDER_RPC!,
    WALLET_PRIVATE_KEY: process.env.WALLET_PRIVATE_KEY!,
    SUBNET_ID: process.env.SUBNET_ID!,
    POSTGRES_URL: process.env.DATABASE_URL!,
    SERVER_COST_CONTRACT_ADDRESS: process.env.SERVER_COST_CONTRACT_ADDRESS!,
  };

  await initAIAccessPoint(
    env,
    skyNode,
    app,
    naturalFunction,
    true, // Enable balance updates
    undefined, // No upload support
    { sendAuthLinkFunction }
  );
};

// 2. Natural Function Pattern
const naturalFunction = async (req, res, balanceRunMain, responseHandler) => {
  try {
    const { prompt, accountNFT, userAuthPayload } = req.body;
    
    // 1. Send progress update
    responseHandler.sendUpdate("Processing request...");
    
    // 2. Call AI model
    const completion = await balanceRunMain.callAIModel(messages, userAuthPayload, accountNFT);
    
    // 3. Parse AI response
    const params = JSON.parse(completion.message);
    
    // 4. Execute service logic
    const result = await executeServiceLogic(params);
    
    // 5. Calculate cost
    const cost = BigInt(0.01 * 1e12);
    
    // 6. Send response
    responseHandler.sendFinalResponse({
      success: true,
      data: { result, params }
    });
    
    // 7. Add cost
    await balanceRunMain.addCost(accountNFT, cost.toString());
    
  } catch (error) {
    responseHandler.sendError(error.message, 500);
  }
};

// 3. Auth Link Function Pattern
const sendAuthLinkFunction = async (req, res, balanceRunMain, userAddress, provider) => {
  try {
    // Generate OAuth URL for the service
    const authUrl = generateOAuthURL(userAddress, provider);
    
    return { success: true, authUrl };
  } catch (error) {
    return { success: false, error: error.message };
  }
};
```

## 9. **Debugging and Logging Patterns**

```typescript
// SDK Debugging Patterns

// 1. Log authentication data structure
console.log('Auth signature structure:', JSON.stringify(signature, null, 2));

// 2. Log request body structure
console.log('Request body:', JSON.stringify(req.body, null, 2));

// 3. Log AI model responses
console.log('AI completion:', completion.message);

// 4. Log cost calculations
console.log(`Cost calculated: ${cost} for user: ${accountNFT.collectionID}_${accountNFT.nftID}`);

// 5. Log service responses
console.log('Service response:', JSON.stringify(serviceResponse, null, 2));
```

## 10. **SDK Best Practices**

```typescript
// Sky AI Access Point Best Practices

const bestPractices = {
  // 1. Always validate input data
  validateInput: (req) => {
    const { prompt, accountNFT, userAuthPayload } = req.body;
    if (!prompt || !accountNFT || !userAuthPayload) {
      throw new Error('Missing required fields');
    }
  },
  
  // 2. Use proper error handling
  handleErrors: (error, responseHandler) => {
    console.error('Service error:', error);
    responseHandler.sendError(
      error instanceof Error ? error.message : 'Unknown error',
      500
    );
  },
  
  // 3. Calculate costs appropriately
  calculateCost: (action, dataSize = 0) => {
    const baseCost = 0.01;
    const dataCost = dataSize * 0.001;
    return BigInt((baseCost + dataCost) * 1e12);
  },
  
  // 4. Use progress updates
  sendProgressUpdates: (responseHandler) => {
    responseHandler.sendUpdate("Initializing...");
    responseHandler.sendUpdate("Processing data...");
    responseHandler.sendUpdate("Finalizing...");
  },
  
  // 5. Structure responses consistently
  structureResponse: (result, params) => ({
    success: true,
    message: "Request completed successfully",
    data: {
      result,
      extractedParams: params,
      timestamp: new Date().toISOString(),
      service: 'your-service-name'
    }
  })
};
```

## 11. **Common SDK Patterns and Gotchas**

```typescript
// Important SDK Patterns and Things to Remember

const sdkPatterns = {
  // 1. Authentication Data Structure
  // The Sky AI SDK returns authentication in this format:
  authStructure: {
    success: true,
    data: {
      userAddress: "0x...",
      signature: "0x...",
      message: "timestamp"
    }
  },
  
  // 2. Always use signature.data for requests, not the full signature object
  correctUsage: (signature) => ({
    userAuthPayload: signature.data, // ✅ Correct
    // userAuthPayload: signature,   // ❌ Wrong
  }),
  
  // 3. Cost calculation should always be BigInt in wei
  costCalculation: (dollarAmount) => BigInt(dollarAmount * 1e12),
  
  // 4. ResponseHandler methods don't return promises
  responseHandlerUsage: (responseHandler) => {
    responseHandler.sendUpdate("Processing..."); // ✅ No await needed
    responseHandler.sendFinalResponse({...});     // ✅ No await needed
  },
  
  // 5. AI model calls should be arrays of message objects
  aiModelFormat: [
    { role: "system", content: "System prompt" },
    { role: "user", content: "User request" }
  ]
};
```

## 12. **Upload vs Non-Upload Patterns**

```typescript
// Upload Support Patterns

// 1. With Upload Support (use FormData)
const withUploadSupport = {
  // Server setup
  setup: () => {
    const upload = multer({ storage: multer.memoryStorage() });
    return initAIAccessPoint(env, skyNode, app, naturalFunction, true, upload, options);
  },
  
  // Request handling
  handleRequest: (req) => {
    const { prompt, accountNFT, userAuthPayload } = req.body;
    const files = req.files as Express.Multer.File[];
    // Process files...
  },
  
  // Client request (FormData)
  clientRequest: () => {
    const formData = new FormData();
    formData.append('prompt', 'Your request');
    formData.append('accountNFT', JSON.stringify({...}));
    formData.append('userAuthPayload', JSON.stringify({...}));
    formData.append('files', fileBuffer, 'filename.jpg');
    
    return axios.post(url, formData, {
      headers: { 'Content-Type': 'multipart/form-data' }
    });
  }
};

// 2. Without Upload Support (use JSON)
const withoutUploadSupport = {
  // Server setup
  setup: () => {
    return initAIAccessPoint(env, skyNode, app, naturalFunction, true, undefined, options);
  },
  
  // Request handling
  handleRequest: (req) => {
    const { prompt, accountNFT, userAuthPayload } = req.body;
    // No files to process
  },
  
  // Client request (JSON)
  clientRequest: () => {
    return axios.post(url, {
      prompt: 'Your request',
      accountNFT: {...},
      userAuthPayload: {...}
    }, {
      headers: { 'Content-Type': 'application/json' }
    });
  }
};
```

## Project Structure
```
project/
├── src/
│   ├── index.ts                 # Main server entry point
│   ├── clients/
│   │   ├── skynet.ts           # Skynet client configuration
│   │   └── openai.ts           # OpenAI client (or any other service)
│   ├── services/
│   │   └── analyzer.ts         # Service-specific logic
│   ├── utils/
│   │   └── validation.ts       # Parameter validation
│   └── tests/
│       └── test-stream.ts      # Streaming test script
├── .env                        # Environment variables
├── package.json                # Dependencies
└── tsconfig.json              # TypeScript configuration
```

## Required Dependencies
```json
{
  "@decloudlabs/sky-ai-accesspoint": "0.0.82",
  "@decloudlabs/skynet": "0.6.25",
  "@ethersproject/wallet": "^5.7.0",
  "@supabase/supabase-js": "^2.39.0",
  "@types/socket.io": "^3.0.1",
  "axios": "^1.9.0",
  "ethers": "^6.14.3",
  "express": "^4.19.2",
  "firebase-admin": "^13.1.0",
  "jsonwebtoken": "^9.0.2",
  "multer": "^1.4.5-lts.1",
  "openai": "^4.70.2",
  "pg": "^8.15.6",
  "socket.io": "^4.8.1"
}
```

## Dev Dependencies
```json
{
  "@types/cors": "^2.8.17",
  "@types/express": "^4.17.21",
  "@types/jsonwebtoken": "^9.0.0",
  "@types/multer": "^1.4.12",
  "@types/pg": "^8.15.0",
  "nodemon": "^3.1.7",
  "ts-node": "^10.9.1",
  "typescript": "^5.0.0"
}
```

## Environment Variables
```env
# Blockchain Configuration (Required)
PROVIDER_RPC=<your-json-rpc-url>
WALLET_PRIVATE_KEY=<your-wallet-private-key>
SUBNET_ID=<your-subnet-id>

# Database (Required)
DATABASE_URL=<your-postgresql-url>

# AI Service (Required - choose one)
OPENROUTER_API_KEY=<your-openrouter-key>
OPENAI_API_KEY=<your-openai-key>

# External APIs (Required for specific services)
RAPIDAPI_KEY=<your-rapidapi-key>

# Storage (Optional - can use any placeholder string)
LIGHTHOUSE_API_KEY=optional_or_any_string
IPFS_PROJECT_ID=optional_or_any_string
IPFS_PROJECT_SECRET=optional_or_any_string
CLOUD_BUCKET_NAME=optional_or_any_string
CLOUD_ACCESS_KEY_ID=optional_or_any_string
CLOUD_SECRET_ACCESS_KEY=optional_or_any_string
CLOUD_REGION=optional_or_any_string

# Server Cost Contract (Optional)
SERVER_COST_CONTRACT_ADDRESS=optional_or_any_string
```

## Advanced Server Setup Pattern
Always follow this structure for advanced server implementation:

### **Option 1: With File Upload Support**
```typescript
import dotenv from "dotenv";
dotenv.config();
import express, { Request, Response } from "express";
import SkyMainNodeJS from "@decloudlabs/skynet/lib/services/SkyMainNodeJS";
import { getSkyNode } from "./clients/skynet";
import { initAIAccessPoint, SendAuthLinkFunctionType } from "@decloudlabs/sky-ai-accesspoint/lib/init";
import cors from "cors";
import bodyParser from "body-parser";
import multer from "multer";
import BalanceRunMain from '@decloudlabs/sky-ai-accesspoint/lib/balanceRunMain';
import { ResponseHandler } from '@decloudlabs/sky-ai-accesspoint/lib/types/types';

const app = express();
app.use(cors());
app.use(bodyParser.json());
const port = process.env.PORT || 3000;

// File upload configuration for multipart form data
const upload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 50 * 1024 * 1024, // 50MB limit
  },
});

// Natural function with file upload support
const runNaturalFunction = async (
  req: Request,
  res: Response,
  balanceRunMain: BalanceRunMain,
  responseHandler: ResponseHandler
): Promise<void> => {
  try {
    const { prompt, accountNFT, userAuthPayload } = req.body;
    const files = req.files as Express.Multer.File[]; // Files from multipart form

    // Send progress update
    responseHandler.sendUpdate("Processing your request with files...");

    // Handle uploaded files
    if (files && files.length > 0) {
      responseHandler.sendUpdate(`Processing ${files.length} uploaded files...`);
      files.forEach((file, index) => {
        console.log(`File ${index + 1}: ${file.originalname}, Size: ${file.size} bytes`);
      });
    }

    // Step 1: Use AI to parse and extract parameters from user request
    const completion = await balanceRunMain.callAIModel(`[
      {
        "role": "system",
        "content": "You are a helpful assistant that extracts parameters from user requests. Return only valid JSON with the required fields."
      },
      {
        "role": "user",
        "content": "${prompt}"
      }
    ]`, userAuthPayload, accountNFT);

    if (!completion.success) {
      responseHandler.sendError(completion.message, 500);
      return;
    }

    // Step 2: Parse AI response to get structured parameters
    let params;
    console.log("AI completion message:", completion.message);
    try {
      params = JSON.parse(completion.message || "");
    } catch (parseError) {
      responseHandler.sendError("Failed to parse AI response parameters", 500);
      return;
    }

    // Step 3: Process the extracted parameters
    responseHandler.sendUpdate("Processing extracted parameters...");
    
    // Example: Process based on extracted action
    let processedResult;
    if (params.action === 'analyze') {
      processedResult = `Analyzing: ${params.domain || 'unknown domain'}`;
    } else if (params.action === 'generate') {
      processedResult = `Generating content for: ${params.keyword || 'unknown keyword'}`;
    } else {
      processedResult = `Processed: ${prompt}`;
    }
    
    // Calculate cost (example: 0.01 tokens per request + 0.001 per file)
    const baseCost = BigInt(0.01 * 1e12);
    const fileCost = BigInt((files?.length || 0) * 0.001 * 1e12);
    const totalCost = baseCost + fileCost;
    
    // Send final response
    responseHandler.sendFinalResponse({
      success: true,
      message: "Request completed successfully",
      data: {
        result: processedResult,
        extractedParams: params,
        filesProcessed: files?.length || 0,
        timestamp: new Date().toISOString()
      }
    });

    // Add cost to user's balance
    await balanceRunMain.addCost(accountNFT, totalCost.toString());
    console.log(`Added cost: ${totalCost} for user: ${accountNFT.collectionID}_${accountNFT.nftID}`);

  } catch (error) {
    console.error("Error processing request:", error);
    responseHandler.sendError(
      error instanceof Error ? error.message : "Failed to process request",
      500
    );
  }
};

// Simple auth link function example
const sendAuthLinkFunction: SendAuthLinkFunctionType = async (
  req: Request,
  res: Response,
  balanceRunMain: BalanceRunMain,
  userAddress: string,
  provider: string = 'google'
): Promise<{
  success: boolean;
  authUrl?: string;
  error?: string;
}> => {
  try {
    // Generate simple auth URL
    const authUrl = `https://example.com/auth?provider=${provider}&user=${userAddress}`;
    
    return {
      success: true,
      authUrl
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Failed to generate auth link'
    };
  }
};

const setup = async () => {
  const skyNode: SkyMainNodeJS = await getSkyNode();
  const env = {
    JSON_RPC_PROVIDER: process.env.PROVIDER_RPC!,
    WALLET_PRIVATE_KEY: process.env.WALLET_PRIVATE_KEY!,
    SUBNET_ID: process.env.SUBNET_ID!,
    POSTGRES_URL: process.env.DATABASE_URL!,
    SERVER_COST_CONTRACT_ADDRESS: process.env.SERVER_COST_CONTRACT_ADDRESS!,
  };

  const balanceRunMain = await initAIAccessPoint(
    env,
    skyNode,
    app,
    runNaturalFunction,
    true, // Enable balance updates
    upload, // File upload middleware (required for upload support)
    {
      sendAuthLinkFunction // Pass the developer's auth link function
    }
  );

  if (!balanceRunMain.success) {
    console.error("Error initializing AI Access Point:", balanceRunMain);
    process.exit(1);
  }

  // Simple health check endpoint
  app.get('/health', (req: Request, res: Response) => {
    res.json({ 
      status: 'healthy', 
      uploadSupport: true,
      timestamp: new Date().toISOString()
    });
  });

  app.listen(port, () => {
    console.log(`Service is running on http://localhost:${port}`);
    console.log(`Health check: http://localhost:${port}/health`);
  });
};

setup().catch(console.error);
```

### **Option 2: Without File Upload Support**
```typescript
import dotenv from "dotenv";
dotenv.config();
import express, { Request, Response } from "express";
import SkyMainNodeJS from "@decloudlabs/skynet/lib/services/SkyMainNodeJS";
import { getSkyNode } from "./clients/skynet";
import { initAIAccessPointWithoutUpload, SendAuthLinkFunctionType } from "@decloudlabs/sky-ai-accesspoint/lib/init";
import cors from "cors";
import bodyParser from "body-parser";
import BalanceRunMain from '@decloudlabs/sky-ai-accesspoint/lib/balanceRunMain';
import { ResponseHandler } from '@decloudlabs/sky-ai-accesspoint/lib/types/types';

const app = express();
app.use(cors());
app.use(bodyParser.json());
const port = process.env.PORT || 3000;

// Natural function without file upload support
const runNaturalFunction = async (
  req: Request,
  res: Response,
  balanceRunMain: BalanceRunMain,
  responseHandler: ResponseHandler
): Promise<void> => {
  try {
    const { prompt, accountNFT, userAuthPayload } = req.body;

    // Send progress update
    responseHandler.sendUpdate("Processing your request...");

    // Step 1: Use AI to parse and extract parameters from user request
    const completion = await balanceRunMain.callAIModel(`[
      {
        "role": "system",
        "content": "You are a helpful assistant that extracts parameters from user requests. Return only valid JSON with the required fields."
      },
      {
        "role": "user",
        "content": "${prompt}"
      }
    ]`, userAuthPayload, accountNFT);

    if (!completion.success) {
      responseHandler.sendError(completion.message, 500);
      return;
    }

    // Step 2: Parse AI response to get structured parameters
    let params;
    console.log("AI completion message:", completion.message);
    try {
      params = JSON.parse(completion.message || "");
    } catch (parseError) {
      responseHandler.sendError("Failed to parse AI response parameters", 500);
      return;
    }

    // Step 3: Process the extracted parameters
    responseHandler.sendUpdate("Processing extracted parameters...");
    
    // Example: Process based on extracted action
    let processedResult;
    if (params.action === 'analyze') {
      processedResult = `Analyzing: ${params.domain || 'unknown domain'}`;
    } else if (params.action === 'generate') {
      processedResult = `Generating content for: ${params.keyword || 'unknown keyword'}`;
    } else {
      processedResult = `Processed: ${prompt}`;
    }
    
    // Calculate cost (example: 0.01 tokens per request)
    const cost = BigInt(0.01 * 1e12); // Convert to wei equivalent
    
    // Send final response
    responseHandler.sendFinalResponse({
      success: true,
      message: "Request completed successfully",
      data: {
        result: processedResult,
        extractedParams: params,
        timestamp: new Date().toISOString()
      }
    });

    // Add cost to user's balance
    await balanceRunMain.addCost(accountNFT, cost.toString());
    console.log(`Added cost: ${cost} for user: ${accountNFT.collectionID}_${accountNFT.nftID}`);

  } catch (error) {
    console.error("Error processing request:", error);
    responseHandler.sendError(
      error instanceof Error ? error.message : "Failed to process request",
      500
    );
  }
};

// Simple auth link function example
const sendAuthLinkFunction: SendAuthLinkFunctionType = async (
  req: Request,
  res: Response,
  balanceRunMain: BalanceRunMain,
  userAddress: string,
  provider: string = 'google'
): Promise<{
  success: boolean;
  authUrl?: string;
  error?: string;
}> => {
  try {
    // Generate simple auth URL
    const authUrl = `https://example.com/auth?provider=${provider}&user=${userAddress}`;
    
    return {
      success: true,
      authUrl
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Failed to generate auth link'
    };
  }
};

const setup = async () => {
  const skyNode: SkyMainNodeJS = await getSkyNode();
  const env = {
    JSON_RPC_PROVIDER: process.env.PROVIDER_RPC!,
    WALLET_PRIVATE_KEY: process.env.WALLET_PRIVATE_KEY!,
    SUBNET_ID: process.env.SUBNET_ID!,
    POSTGRES_URL: process.env.DATABASE_URL!,
    SERVER_COST_CONTRACT_ADDRESS: process.env.SERVER_COST_CONTRACT_ADDRESS!,
  };

  const balanceRunMain = await initAIAccessPointWithoutUpload(
    env,
    skyNode,
    app,
    runNaturalFunction,
    true, // Enable balance updates
    {
      sendAuthLinkFunction // Pass the developer's auth link function
    }
  );

  if (!balanceRunMain.success) {
    console.error("Error initializing AI Access Point:", balanceRunMain);
    process.exit(1);
  }

  // Simple health check endpoint
  app.get('/health', (req: Request, res: Response) => {
    res.json({ 
      status: 'healthy', 
      uploadSupport: false,
      timestamp: new Date().toISOString()
    });
  });

  app.listen(port, () => {
    console.log(`Service is running on http://localhost:${port}`);
    console.log(`Health check: http://localhost:${port}/health`);
  });
};

setup().catch(console.error);
```

## Test Script Patterns

### **Test Script for Upload Support (Multipart Form Data)**
```typescript
import { getSkyNode } from "./clients/skynet";
import SkyMainNodeJS from "@decloudlabs/skynet/lib/services/SkyMainNodeJS";
import axios from "axios";
import FormData from "form-data";
import fs from "fs";

const testUploadRequest = async () => {
  try {
    const skyNode: SkyMainNodeJS = await getSkyNode();
    const signature = await skyNode.appManager.getUrsulaAuth();

    console.log("Testing upload request...");

    // Create form data
    const formData = new FormData();
    
    // Add files
    formData.append('files', fs.createReadStream('./test-file.txt'), {
      filename: 'test-file.txt',
      contentType: 'text/plain'
    });
    
    // Add JSON data as strings
    formData.append('prompt', JSON.stringify("Analyze the uploaded file"));
    formData.append('userAuthPayload', JSON.stringify(signature.data));
    formData.append('accountNFT', JSON.stringify({
      "collectionID": "0",
      "nftID": "53"
    }));

    // Make request
    const response = await axios.post('http://localhost:3000/natural-request', formData, {
      headers: {
        ...formData.getHeaders(),
        'Content-Type': 'multipart/form-data'
      }
    });

    console.log("Upload response:", response.data);
  } catch (error) {
    console.error("Upload test error:", error.response?.data || error.message);
  }
};

testUploadRequest();
```

### **Test Script for Non-Upload Support (JSON)**
```typescript
import { getSkyNode } from "./clients/skynet";
import SkyMainNodeJS from "@decloudlabs/skynet/lib/services/SkyMainNodeJS";
import axios from "axios";

const testNonUploadRequest = async () => {
  try {
    const skyNode: SkyMainNodeJS = await getSkyNode();
    const signature = await skyNode.appManager.getUrsulaAuth();

    console.log("Testing non-upload request...");

    // Make JSON request
    const response = await axios.post('http://localhost:3000/natural-request', {
      prompt: "Analyze the domain example.com",
      userAuthPayload: signature.data,
      accountNFT: {
        "collectionID": "0",
        "nftID": "53"
      }
    }, {
      headers: {
        'Content-Type': 'application/json'
      }
    });

    console.log("Non-upload response:", response.data);
  } catch (error) {
    console.error("Non-upload test error:", error.response?.data || error.message);
  }
};

testNonUploadRequest();
```

### **Socket.IO Test Script (Supports Both Upload and Non-Upload)**
```typescript
import { getSkyNode } from "./clients/skynet";
import SkyMainNodeJS from "@decloudlabs/skynet/lib/services/SkyMainNodeJS";
import { io } from "socket.io-client";

const testSocketIORequest = async () => {
  try {
    const skyNode: SkyMainNodeJS = await getSkyNode();
    const signature = await skyNode.appManager.getUrsulaAuth();

    console.log("Connecting to Socket.IO server...");

    const socket = io("http://localhost:3000", {
      path: "/socket.io"
    });

    socket.on("connect", () => {
      console.log("Connected to Socket.IO server");
      
      // Send natural request via Socket.IO (no file upload support in Socket.IO)
      socket.emit("natural_request", {
        prompt: "Analyze the domain example.com",
        accountNFT: {
          "collectionID": "0",
          "nftID": "53"
        },
        userAuthPayload: signature.data,
        correlationId: "test-" + Date.now()
      });
    });

    socket.on("task_update", (data) => {
      console.log("Task update:", data);
      
      if (data.status === "completed") {
        console.log("Task completed:", data.data);
        socket.disconnect();
      } else if (data.status === "failed") {
        console.error("Task failed:", data.error);
        socket.disconnect();
      }
    });

    socket.on("disconnect", () => {
      console.log("Disconnected from server");
    });

  } catch (error) {
    console.error("Socket.IO test error:", error);
  }
};

testSocketIORequest();
```

## Skynet Client Pattern
Always use this structure for Skynet client:

```typescript
import SkyMainNodeJS from '@decloudlabs/skynet/lib/services/SkyMainNodeJS';
import SkyEnvConfigNodeJS from '@decloudlabs/skynet/lib/types/types';
import dotenv from 'dotenv';
dotenv.config();

let initializedAppCrypto: SkyMainNodeJS;

const initializeSkyNodeCrypto = async (): Promise<SkyMainNodeJS> => {
  if (!initializedAppCrypto) {
    const envConfig: SkyEnvConfigNodeJS = {
      JRPC_PROVIDER: process.env.PROVIDER_RPC!,
      WALLET_PRIVATE_KEY: process.env.WALLET_PRIVATE_KEY!,
      STORAGE_API: {
        LIGHTHOUSE: {
          LIGHTHOUSE_API_KEY: process.env.LIGHTHOUSE_API_KEY!
        },
        IPFS: {
          PROJECT_ID: process.env.IPFS_PROJECT_ID!,
          PROJECT_SECRET: process.env.IPFS_PROJECT_SECRET!
        },
        CLOUD: {
          BUCKET_NAME: process.env.CLOUD_BUCKET_NAME!,
          ACCESS_KEY_ID: process.env.CLOUD_ACCESS_KEY_ID!,
          SECRET_ACCESS_KEY: process.env.CLOUD_SECRET_ACCESS_KEY!,
          REGION: process.env.CLOUD_REGION!
        }
      }
    };
    initializedAppCrypto = new SkyMainNodeJS(envConfig);
    await initializedAppCrypto.init(true);
  }
  return initializedAppCrypto;
};

export const getSkyNode = async (): Promise<SkyMainNodeJS> => {
  return await initializeSkyNodeCrypto();
};
```

## Service Integration Pattern
Use this pattern for external service integration:

```typescript
export class YourService {
  private apiKey: string;

  constructor(apiKey: string) {
    this.apiKey = apiKey;
  }

  async testConnection(): Promise<{ primary: boolean; secondary?: boolean }> {
    try {
      // Test primary API
      const primaryTest = await this.testPrimaryAPI();
      
      // Test secondary API if needed
      const secondaryTest = await this.testSecondaryAPI();
      
      return {
        primary: primaryTest,
        secondary: secondaryTest
      };
    } catch (error) {
      return { primary: false, secondary: false };
    }
  }

  async analyze(params: any): Promise<{ success: boolean; data?: any; error?: string }> {
    try {
      // Your analysis logic here
      const result = await this.performAnalysis(params);
      
      return {
        success: true,
        data: result
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  private async testPrimaryAPI(): Promise<boolean> {
    // Test your primary API
    return true;
  }

  private async testSecondaryAPI(): Promise<boolean> {
    // Test your secondary API
    return true;
  }

  private async performAnalysis(params: any): Promise<any> {
    // Your analysis implementation
    return {};
  }
}
```

## Socket.IO Test Pattern
Use this pattern for Socket.IO testing:

```typescript
import { getSkyNode } from "./clients/skynet";
import SkyMainNodeJS from "@decloudlabs/skynet/lib/services/SkyMainNodeJS";
import { io } from "socket.io-client";

const main = async () => {
  try {
    const skyNode: SkyMainNodeJS = await getSkyNode();
    const signature = await skyNode.appManager.getUrsulaAuth();

    console.log("Connecting to Socket.IO server...");

    const socket = io("http://localhost:3000", {
      path: "/socket.io"
    });

    socket.on("connect", () => {
      console.log("Connected to Socket.IO server");
      
      // Send natural request via Socket.IO
      socket.emit("natural_request", {
        prompt: "Analyze the domain example.com",
        accountNFT: {
          "collectionID": "0",
          "nftID": "53"
        },
        userAuthPayload: signature.data,
        correlationId: "test-" + Date.now()
      });
    });

    socket.on("task_update", (data) => {
      console.log("Task update:", data);
      
      if (data.status === "completed") {
        console.log("Task completed:", data.data);
        socket.disconnect();
      } else if (data.status === "failed") {
        console.error("Task failed:", data.error);
        socket.disconnect();
      }
    });

    socket.on("disconnect", () => {
      console.log("Disconnected from server");
    });

  } catch (error) {
    console.error("Error:", error);
  }
};

main();
```

## Authentication Rules

### API Key Authentication
- Always use `x-api-key` header for API key authentication
- API keys are validated through the middleware
- NFT ownership is automatically attached to requests

### NFT Authentication
- Use `accountNFT` object with `collectionID` and `nftID`
- Use `userAuthPayload` from `skyNode.appManager.getUrsulaAuth()`
- Balance checking is automatic

### Third-Party Auth
- Use `/auth-link` endpoint to get authentication URLs
- Use `/auth-status` endpoint to check connection status
- Store auth data using `saveAuth()` function (developer only)
- Retrieve auth data using `getAuth()` function (developer only)

## Complete Authentication Implementation Rules

### **IMPORTANT: Always Implement Full Authentication Flows**
When implementing authentication, NEVER use placeholder code. Always provide complete, working implementations:

1. **Single Service Focus**: Each access point supports ONE specific service (e.g., Gmail, Google Meet, GitHub, etc.)
2. **Complete Token Exchange**: Handle code-to-token exchange properly
3. **User Profile Retrieval**: Fetch and store actual user profiles
4. **Token Refresh**: Implement token refresh mechanisms
5. **Error Handling**: Handle all OAuth error scenarios
6. **Security**: Implement proper state validation and CSRF protection
7. **Flexible Storage**: Auth data can store ANY JSON information related to the service

### **Required Environment Variables for Auth**
```env
# OAuth Configuration (Required for auth services)
# Example for Gmail access point:
GOOGLE_CLIENT_ID=<your-google-client-id>
GOOGLE_CLIENT_SECRET=<your-google-client-secret>

# Callback URLs
AUTH_CALLBACK_URL=http://localhost:3000/auth/callback
FRONTEND_URL=http://localhost:3000

# JWT Secret (for session management)
JWT_SECRET=<your-jwt-secret>
```

### **Complete Auth Link Function Implementation (Single Service)**
```typescript
import axios from 'axios';
import crypto from 'crypto';

// Complete auth link function for Gmail service (example)
const sendAuthLinkFunction: SendAuthLinkFunctionType = async (
  req: Request,
  res: Response,
  balanceRunMain: BalanceRunMain,
  userAddress: string,
  provider: string = 'gmail' // Single service focus
): Promise<{
  success: boolean;
  authUrl?: string;
  error?: string;
}> => {
  try {
    // Generate secure state parameter
    const state = crypto.randomBytes(32).toString('hex');
    const timestamp = Date.now();
    const stateData = {
      userAddress,
      service: 'gmail', // Specific service
      timestamp,
      nonce: crypto.randomBytes(16).toString('hex')
    };
    
    // Store state for validation
    await storeAuthState(state, stateData);

    // Generate Gmail-specific OAuth URL
    const authUrl = `https://accounts.google.com/oauth/authorize?` +
      `client_id=${process.env.GOOGLE_CLIENT_ID}&` +
      `redirect_uri=${encodeURIComponent(process.env.AUTH_CALLBACK_URL!)}&` +
      `response_type=code&` +
      `scope=${encodeURIComponent('https://www.googleapis.com/auth/gmail.readonly https://www.googleapis.com/auth/gmail.send')}&` +
      `state=${state}&` +
      `access_type=offline&` +
      `prompt=consent`;

    return {
      success: true,
      authUrl
    };
  } catch (error) {
    console.error('Error generating auth link:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Failed to generate auth link'
    };
  }
};

// Complete OAuth callback handler for Gmail
const handleOAuthCallback = async (req: Request, res: Response) => {
  try {
    const { code, state, error } = req.query;
    
    if (error) {
      return res.status(400).json({
        success: false,
        error: `OAuth error: ${error}`
      });
    }
    
    if (!code || !state) {
      return res.status(400).json({
        success: false,
        error: 'Missing code or state parameter'
      });
    }

    // Retrieve and validate state
    const stateData = await getAuthState(state as string);
    if (!stateData) {
      return res.status(400).json({
        success: false,
        error: 'Invalid or expired state parameter'
      });
    }

    const { userAddress, service } = stateData;

    // Exchange code for tokens
    const tokenData = await exchangeCodeForTokens(code as string);
    if (!tokenData.success) {
      return res.status(400).json({
        success: false,
        error: tokenData.error
      });
    }

    // Get Gmail user profile and additional data
    const profileData = await getGmailUserData(tokenData.accessToken);
    if (!profileData.success) {
      return res.status(400).json({
        success: false,
        error: profileData.error
      });
    }

    // Save comprehensive authentication data (any JSON format)
    const authData = {
      service: 'gmail',
      access_token: tokenData.accessToken,
      refresh_token: tokenData.refreshToken,
      expires_at: tokenData.expiresAt,
      userAddress,
      // Gmail-specific data
      profile: profileData.profile,
      emailAddress: profileData.emailAddress,
      labels: profileData.labels,
      quota: profileData.quota,
      // Additional service-specific data
      lastSync: new Date().toISOString(),
      settings: {
        autoReply: false,
        signature: '',
        filters: []
      },
      // Any other Gmail-related information
      metadata: {
        accountType: 'gmail',
        permissions: ['read', 'send'],
        connectedAt: new Date().toISOString()
      }
    };

    await saveAuth(userAddress, authData);

    // Clean up state
    await removeAuthState(state as string);

    // Redirect to frontend with success
    const redirectUrl = `${process.env.FRONTEND_URL}/auth/success?service=gmail&userAddress=${userAddress}`;
    res.redirect(redirectUrl);

  } catch (error) {
    console.error('OAuth callback error:', error);
    const redirectUrl = `${process.env.FRONTEND_URL}/auth/error?error=${encodeURIComponent(error instanceof Error ? error.message : 'Unknown error')}`;
    res.redirect(redirectUrl);
  }
};

// Complete token exchange for Gmail
const exchangeCodeForTokens = async (code: string): Promise<{
  success: boolean;
  accessToken?: string;
  refreshToken?: string;
  expiresAt?: number;
  error?: string;
}> => {
  try {
    const tokenResponse = await axios.post('https://oauth2.googleapis.com/token', {
      client_id: process.env.GOOGLE_CLIENT_ID,
      client_secret: process.env.GOOGLE_CLIENT_SECRET,
      code,
      grant_type: 'authorization_code',
      redirect_uri: process.env.AUTH_CALLBACK_URL
    });

    const data = tokenResponse.data;
    
    return {
      success: true,
      accessToken: data.access_token,
      refreshToken: data.refresh_token,
      expiresAt: data.expires_in ? Date.now() + (data.expires_in * 1000) : undefined
    };
  } catch (error) {
    console.error('Token exchange error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Token exchange failed'
    };
  }
};

// Complete Gmail user data retrieval
const getGmailUserData = async (accessToken: string): Promise<{
  success: boolean;
  profile?: any;
  emailAddress?: string;
  labels?: any[];
  quota?: any;
  error?: string;
}> => {
  try {
    // Get user profile
    const profileResponse = await axios.get('https://www.googleapis.com/oauth2/v2/userinfo', {
      headers: {
        'Authorization': `Bearer ${accessToken}`
      }
    });

    // Get Gmail profile
    const gmailResponse = await axios.get('https://gmail.googleapis.com/gmail/v1/users/me/profile', {
      headers: {
        'Authorization': `Bearer ${accessToken}`
      }
    });

    // Get Gmail labels
    const labelsResponse = await axios.get('https://gmail.googleapis.com/gmail/v1/users/me/labels', {
      headers: {
        'Authorization': `Bearer ${accessToken}`
      }
    });

    return {
      success: true,
      profile: profileResponse.data,
      emailAddress: gmailResponse.data.emailAddress,
      labels: labelsResponse.data.labels || [],
      quota: {
        total: gmailResponse.data.messagesTotal,
        unread: gmailResponse.data.messagesUnread
      }
    };
  } catch (error) {
    console.error('Gmail data retrieval error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Gmail data retrieval failed'
    };
  }
};

// State management functions
const storeAuthState = async (state: string, data: any): Promise<void> => {
  global.authStates = global.authStates || new Map();
  global.authStates.set(state, { ...data, createdAt: Date.now() });
};

const getAuthState = async (state: string): Promise<any> => {
  global.authStates = global.authStates || new Map();
  const stateData = global.authStates.get(state);
  
  if (!stateData) return null;
  
  // Check if state is expired (5 minutes)
  if (Date.now() - stateData.createdAt > 5 * 60 * 1000) {
    global.authStates.delete(state);
    return null;
  }
  
  return stateData;
};

const removeAuthState = async (state: string): Promise<void> => {
  global.authStates = global.authStates || new Map();
  global.authStates.delete(state);
};
```

### **Complete Auth Endpoints Implementation (Single Service)**
```typescript
// Add these endpoints to your Express app

// OAuth callback endpoint
app.get('/auth/callback', handleOAuthCallback);

// Auth status endpoint for Gmail
app.get('/auth/status/:userAddress', async (req: Request, res: Response) => {
  try {
    const { userAddress } = req.params;
    
    const authData = await getAuth(userAddress, 'gmail');
    if (!authData) {
      return res.json({
        success: true,
        connected: false,
        service: 'gmail'
      });
    }

    // Check if token is expired
    const isExpired = authData.expires_at && Date.now() > authData.expires_at;
    
    return res.json({
      success: true,
      connected: !isExpired,
      service: 'gmail',
      emailAddress: authData.emailAddress,
      profile: authData.profile,
      quota: authData.quota,
      lastSync: authData.lastSync,
      lastUpdated: authData.updated_at
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error instanceof Error ? error.message : 'Internal server error'
    });
  }
});

// Refresh token endpoint for Gmail
app.post('/auth/refresh/:userAddress', async (req: Request, res: Response) => {
  try {
    const { userAddress } = req.params;
    
    const authData = await getAuth(userAddress, 'gmail');
    if (!authData || !authData.refresh_token) {
      return res.status(400).json({
        success: false,
        error: 'No refresh token available'
      });
    }

    // Refresh tokens
    const newTokens = await refreshTokens(authData.refresh_token);
    if (!newTokens.success) {
      return res.status(400).json({
        success: false,
        error: newTokens.error
      });
    }

    // Update stored tokens
    const updatedAuthData = {
      ...authData,
      access_token: newTokens.accessToken,
      refresh_token: newTokens.refreshToken || authData.refresh_token,
      expires_at: newTokens.expiresAt,
      lastRefresh: new Date().toISOString()
    };

    await saveAuth(userAddress, updatedAuthData);

    res.json({
      success: true,
      message: 'Token refreshed successfully'
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error instanceof Error ? error.message : 'Internal server error'
    });
  }
});
```

### **Token Refresh Implementation (Single Service)**
```typescript
const refreshTokens = async (refreshToken: string): Promise<{
  success: boolean;
  accessToken?: string;
  refreshToken?: string;
  expiresAt?: number;
  error?: string;
}> => {
  try {
    const refreshResponse = await axios.post('https://oauth2.googleapis.com/token', {
      client_id: process.env.GOOGLE_CLIENT_ID,
      client_secret: process.env.GOOGLE_CLIENT_SECRET,
      refresh_token: refreshToken,
      grant_type: 'refresh_token'
    });

    const data = refreshResponse.data;
    
    return {
      success: true,
      accessToken: data.access_token,
      refreshToken: data.refresh_token,
      expiresAt: data.expires_in ? Date.now() + (data.expires_in * 1000) : undefined
    };
  } catch (error) {
    console.error('Token refresh error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Token refresh failed'
    };
  }
};
```

### **Flexible Auth Data Storage**
```typescript
// Auth data can store ANY JSON information related to the service
// Examples for different services:

// Gmail Service Auth Data
const gmailAuthData = {
  service: 'gmail',
  access_token: 'ya29.a0...',
  refresh_token: '1//04...',
  expires_at: 1703123456789,
  userAddress: '0x1234567890abcdef',
  profile: { name: 'John Doe', email: 'john@gmail.com' },
  emailAddress: 'john@gmail.com',
  labels: ['INBOX', 'SENT', 'DRAFT'],
  quota: { total: 1000, unread: 50 },
  settings: {
    autoReply: false,
    signature: '',
    filters: []
  },
  metadata: {
    accountType: 'gmail',
    permissions: ['read', 'send'],
    connectedAt: new Date().toISOString()
  }
};

// Google Meet Service Auth Data
const meetAuthData = {
  service: 'google-meet',
  access_token: 'ya29.a0...',
  refresh_token: '1//04...',
  expires_at: 1703123456789,
  userAddress: '0x1234567890abcdef',
  profile: { name: 'John Doe', email: 'john@gmail.com' },
  calendarId: 'primary',
  meetingSettings: {
    defaultDuration: 30,
    autoRecord: false,
    waitingRoom: true
  },
  recentMeetings: [
    { id: 'meeting1', title: 'Team Standup', date: '2024-01-15' }
  ]
};

// GitHub Service Auth Data
const githubAuthData = {
  service: 'github',
  access_token: 'ghp_1234567890abcdef',
  refresh_token: null, // GitHub doesn't use refresh tokens
  expires_at: null,
  userAddress: '0x1234567890abcdef',
  profile: { login: 'johndoe', name: 'John Doe' },
  repositories: ['repo1', 'repo2'],
  organizations: ['org1'],
  permissions: ['repo', 'user'],
  webhooks: [
    { id: 1, url: 'https://example.com/webhook', events: ['push'] }
  ]
};
```

## Cost Management Pattern
Always implement cost calculation and charging:

```typescript
// Calculate cost based on action and data complexity
const calculateCost = (action: string, dataPoints: number = 0, hasCompleteData: boolean = false) => {
  let baseCost = 0;
  let dataCost = 0;
  let premiumCost = 0;

  switch (action) {
    case 'analyze':
      baseCost = 0.01;
      dataCost = dataPoints * 0.001;
      premiumCost = hasCompleteData ? 0.005 : 0;
      break;
    case 'generate':
      baseCost = 0.005;
      premiumCost = hasCompleteData ? 0.003 : 0;
      break;
    default:
      baseCost = 0.01;
  }

  const totalCost = (baseCost + dataCost + premiumCost) * 1e12;
  return totalCost;
};

// Charge the user after successful operation
const cost = calculateCost(params.action, result.dataPoints?.length || 0, hasCompleteData);
balanceRunMain.addCost(accountNFT, cost.toFixed(0).toString());
```

## Response Handler Pattern
Always use the ResponseHandler interface for consistent responses:

```typescript
// Send progress updates
responseHandler.sendUpdate("Processing your request...");

// Send final response
responseHandler.sendFinalResponse({
  success: true,
  data: result
});

// Send error
responseHandler.sendError("Error message", 500);
```

## Best Practices
1. Always handle errors in try-catch blocks
2. Use proper TypeScript types from the SDK
3. Initialize Skynet client once and reuse
4. Use environment variables for all configuration
5. Implement proper logging for debugging
6. Use Socket.IO for real-time communication
7. Validate all input data before processing
8. Use the ResponseHandler for consistent API responses
9. Implement cost calculation and charging
10. Test external API connections before processing
11. Provide health check and API test endpoints
12. Use AI to parse and validate user parameters
13. Check data completeness for premium pricing
14. Generate appropriate success messages based on action type

## Development Workflow Rules

### **Project Initialization (REQUIRED)**
Before starting any development:

1. **Check if project is initialized**: Look for `lib/` directory and compiled files
2. **Run initialization if needed**: `npm run build` to compile TypeScript
3. **Verify all dependencies**: `npm install` to ensure all packages are installed
4. **Check environment setup**: Verify `.env` file exists with required variables
5. **Test basic connectivity**: Run health check endpoints

```bash
# Required initialization sequence
npm install
npm run build
npm run dev  # Start in development mode
```

### **Build Validation (REQUIRED)**
After implementing any access point functionality:

1. **Always run build check**: `npm run build`
2. **Fix all TypeScript errors** before proceeding
3. **Resolve any import/export issues**
4. **Ensure all dependencies are properly installed**
5. **Verify type definitions are correct**

```bash
# Required build validation
npm run build

# If errors occur, fix them before continuing
# Common issues to check:
# - Missing imports
# - Type mismatches
# - Unused variables
# - Incorrect function signatures
```

### **Strict TypeScript Test Script Requirements (MANDATORY)**
Every access point MUST include comprehensive TypeScript test scripts:

#### **IMPORTANT: No Testing Frameworks Allowed**
- ❌ **NO Jest** - Do not use Jest testing framework
- ❌ **NO Mocha** - Do not use Mocha testing framework
- ❌ **NO Testing Libraries** - Do not use any testing libraries
- ✅ **ONLY Simple TypeScript** - Use plain TypeScript files
- ✅ **Direct HTTP Calls** - Use axios, fetch, or socket.io-client
- ✅ **Localhost Testing** - Call endpoints directly on localhost

#### **Required Test Files Structure**
```
test/
├── setup.ts                    # Test environment setup
├── auth.test.ts               # Authentication tests
├── natural-request.test.ts    # Natural function tests
├── streaming.test.ts          # HTTP streaming tests
├── socket.test.ts             # Socket.IO tests
├── integration.test.ts        # End-to-end integration tests
└── utils/
    ├── test-helpers.ts        # Test utilities
    └── mock-data.ts           # Mock data generators
```

#### **Mandatory Test Coverage Requirements**
```typescript
// test/natural-request.test.ts - REQUIRED
import axios from 'axios';
import { io as Client } from 'socket.io-client';

// Simple TypeScript test functions - NO Jest/Mocha
async function testRestAPI() {
  console.log('Testing REST API...');
  
  try {
    const response = await axios.post('http://localhost:3000/run-natural-function', {
      userAddress: '0x1234567890abcdef',
      apiKey: 'test-api-key',
      prompt: 'Analyze this data and provide insights'
    });

    if (response.status === 200 && response.data.success) {
      console.log('✅ REST API test passed');
      return true;
    } else {
      console.log('❌ REST API test failed:', response.data);
      return false;
    }
  } catch (error) {
    console.log('❌ REST API test error:', error.response?.data || error.message);
    return false;
  }
}

async function testFileUpload() {
  console.log('Testing file upload...');
  
  try {
    const formData = new FormData();
    formData.append('file', new Blob(['test file content'], { type: 'text/plain' }), 'test.txt');
    formData.append('userAddress', '0x1234567890abcdef');
    formData.append('apiKey', 'test-api-key');
    formData.append('prompt', 'Analyze this file');

    const response = await axios.post('http://localhost:3000/run-natural-function', formData, {
      headers: {
        'Content-Type': 'multipart/form-data'
      }
    });

    if (response.status === 200 && response.data.success) {
      console.log('✅ File upload test passed');
      return true;
    } else {
      console.log('❌ File upload test failed:', response.data);
      return false;
    }
  } catch (error) {
    console.log('❌ File upload test error:', error.response?.data || error.message);
    return false;
  }
}

async function testAuthentication() {
  console.log('Testing authentication...');
  
  try {
    const response = await axios.post('http://localhost:3000/run-natural-function', {
      userAddress: '0x1234567890abcdef',
      prompt: 'Test request without API key'
    });

    if (response.status === 401) {
      console.log('✅ Authentication test passed (correctly rejected)');
      return true;
    } else {
      console.log('❌ Authentication test failed (should have been rejected)');
      return false;
    }
  } catch (error) {
    if (error.response?.status === 401) {
      console.log('✅ Authentication test passed (correctly rejected)');
      return true;
    } else {
      console.log('❌ Authentication test error:', error.response?.data || error.message);
      return false;
    }
  }
}

async function testHttpStreaming() {
  console.log('Testing HTTP streaming...');
  
  try {
    const response = await axios.post('http://localhost:3000/run-natural-function', {
      userAddress: '0x1234567890abcdef',
      apiKey: 'test-api-key',
      prompt: 'Generate a long response',
      stream: true
    }, {
      responseType: 'stream'
    });

    if (response.status === 200 && response.headers['content-type']?.includes('text/event-stream')) {
      console.log('✅ HTTP streaming test passed');
      return true;
    } else {
      console.log('❌ HTTP streaming test failed');
      return false;
    }
  } catch (error) {
    console.log('❌ HTTP streaming test error:', error.response?.data || error.message);
    return false;
  }
}

async function testSocketIO() {
  console.log('Testing Socket.IO...');
  
  return new Promise((resolve) => {
    const client = Client('http://localhost:3000');
    let testPassed = false;

    client.on('connect', () => {
      console.log('Connected to Socket.IO server');
      
      client.emit('natural-function', {
        userAddress: '0x1234567890abcdef',
        apiKey: 'test-api-key',
        prompt: 'Socket.IO test request'
      });
    });

    client.on('response', (data) => {
      if (data.success) {
        console.log('✅ Socket.IO test passed');
        testPassed = true;
      } else {
        console.log('❌ Socket.IO test failed:', data);
      }
      client.disconnect();
      resolve(testPassed);
    });

    client.on('error', (data) => {
      console.log('❌ Socket.IO test error:', data);
      client.disconnect();
      resolve(false);
    });

    // Timeout after 10 seconds
    setTimeout(() => {
      console.log('❌ Socket.IO test timeout');
      client.disconnect();
      resolve(false);
    }, 10000);
  });
}

// Main test runner
async function runAllTests() {
  console.log('🚀 Starting all tests...\n');
  
  const results = {
    rest: await testRestAPI(),
    upload: await testFileUpload(),
    auth: await testAuthentication(),
    streaming: await testHttpStreaming(),
    socket: await testSocketIO()
  };

  console.log('\n📊 Test Results:');
  console.log('REST API:', results.rest ? '✅ PASS' : '❌ FAIL');
  console.log('File Upload:', results.upload ? '✅ PASS' : '❌ FAIL');
  console.log('Authentication:', results.auth ? '✅ PASS' : '❌ FAIL');
  console.log('HTTP Streaming:', results.streaming ? '✅ PASS' : '❌ FAIL');
  console.log('Socket.IO:', results.socket ? '✅ PASS' : '❌ FAIL');

  const allPassed = Object.values(results).every(result => result);
  console.log('\n🎯 Overall Result:', allPassed ? '✅ ALL TESTS PASSED' : '❌ SOME TESTS FAILED');
  
  process.exit(allPassed ? 0 : 1);
}

// Run tests if this file is executed directly
if (require.main === module) {
  runAllTests();
}

export { runAllTests };
```

#### **Authentication Test Script (MANDATORY)**
```typescript
// test/auth.test.ts - REQUIRED
import axios from 'axios';

async function testAuthLinkGeneration() {
  console.log('Testing auth link generation...');
  
  try {
    const response = await axios.post('http://localhost:3000/auth-link', {
      userAddress: '0x1234567890abcdef',
      provider: 'gmail'
    });

    if (response.status === 200 && response.data.success && response.data.authUrl) {
      console.log('✅ Auth link generation test passed');
      console.log('Auth URL:', response.data.authUrl);
      return true;
    } else {
      console.log('❌ Auth link generation test failed:', response.data);
      return false;
    }
  } catch (error) {
    console.log('❌ Auth link generation test error:', error.response?.data || error.message);
    return false;
  }
}

async function testAuthStatus() {
  console.log('Testing auth status...');
  
  try {
    const response = await axios.get('http://localhost:3000/auth-status/0x1234567890abcdef');

    if (response.status === 200 && response.data.success) {
      console.log('✅ Auth status test passed');
      console.log('Auth status:', response.data);
      return true;
    } else {
      console.log('❌ Auth status test failed:', response.data);
      return false;
    }
  } catch (error) {
    console.log('❌ Auth status test error:', error.response?.data || error.message);
    return false;
  }
}

async function testOAuthCallback() {
  console.log('Testing OAuth callback...');
  
  try {
    const response = await axios.get('http://localhost:3000/auth/callback?code=test-code&state=test-state', {
      maxRedirects: 0,
      validateStatus: (status) => status < 400
    });

    if (response.status === 302 || response.status === 200) {
      console.log('✅ OAuth callback test passed');
      return true;
    } else {
      console.log('❌ OAuth callback test failed:', response.status);
      return false;
    }
  } catch (error) {
    if (error.response?.status === 302) {
      console.log('✅ OAuth callback test passed (redirect)');
      return true;
    } else {
      console.log('❌ OAuth callback test error:', error.response?.data || error.message);
      return false;
    }
  }
}

async function testAuthValidation() {
  console.log('Testing auth validation...');
  
  try {
    const response = await axios.post('http://localhost:3000/auth-link', {});

    if (response.status === 400) {
      console.log('✅ Auth validation test passed (correctly rejected)');
      return true;
    } else {
      console.log('❌ Auth validation test failed (should have been rejected)');
      return false;
    }
  } catch (error) {
    if (error.response?.status === 400) {
      console.log('✅ Auth validation test passed (correctly rejected)');
      return true;
    } else {
      console.log('❌ Auth validation test error:', error.response?.data || error.message);
      return false;
    }
  }
}

// Main auth test runner
async function runAuthTests() {
  console.log('🔐 Starting authentication tests...\n');
  
  const results = {
    linkGeneration: await testAuthLinkGeneration(),
    status: await testAuthStatus(),
    callback: await testOAuthCallback(),
    validation: await testAuthValidation()
  };

  console.log('\n📊 Auth Test Results:');
  console.log('Link Generation:', results.linkGeneration ? '✅ PASS' : '❌ FAIL');
  console.log('Auth Status:', results.status ? '✅ PASS' : '❌ FAIL');
  console.log('OAuth Callback:', results.callback ? '✅ PASS' : '❌ FAIL');
  console.log('Validation:', results.validation ? '✅ PASS' : '❌ FAIL');

  const allPassed = Object.values(results).every(result => result);
  console.log('\n🎯 Auth Tests Result:', allPassed ? '✅ ALL AUTH TESTS PASSED' : '❌ SOME AUTH TESTS FAILED');
  
  return allPassed;
}

// Run tests if this file is executed directly
if (require.main === module) {
  runAuthTests().then(success => process.exit(success ? 0 : 1));
}

export { runAuthTests };
```

#### **Integration Test Script (MANDATORY)**
```typescript
// test/integration.test.ts - REQUIRED
import axios from 'axios';
import { io as Client } from 'socket.io-client';

async function testCompleteWorkflow() {
  console.log('🔄 Testing complete workflow...');
  
  try {
    // Step 1: Test auth link generation
    const authResponse = await axios.post('http://localhost:3000/auth-link', {
      userAddress: '0x1234567890abcdef',
      provider: 'gmail'
    });

    if (!authResponse.data.success) {
      console.log('❌ Auth link generation failed');
      return false;
    }

    // Step 2: Test natural function via REST
    const restResponse = await axios.post('http://localhost:3000/run-natural-function', {
      userAddress: '0x1234567890abcdef',
      apiKey: 'test-api-key',
      prompt: 'Integration test request'
    });

    if (!restResponse.data.success) {
      console.log('❌ REST API failed');
      return false;
    }

    // Step 3: Test Socket.IO
    const socketResult = await new Promise((resolve) => {
      const client = Client('http://localhost:3000');
      
      client.on('connect', () => {
        client.emit('natural-function', {
          userAddress: '0x1234567890abcdef',
          apiKey: 'test-api-key',
          prompt: 'Integration test via Socket.IO'
        });
      });

      client.on('response', (data) => {
        client.disconnect();
        resolve(data.success);
      });

      client.on('error', () => {
        client.disconnect();
        resolve(false);
      });

      setTimeout(() => {
        client.disconnect();
        resolve(false);
      }, 5000);
    });

    if (!socketResult) {
      console.log('❌ Socket.IO failed');
      return false;
    }

    console.log('✅ Complete workflow test passed');
    return true;
  } catch (error) {
    console.log('❌ Integration test error:', error.response?.data || error.message);
    return false;
  }
}

async function runIntegrationTests() {
  console.log('🔗 Starting integration tests...\n');
  
  const workflowResult = await testCompleteWorkflow();
  
  console.log('\n📊 Integration Test Results:');
  console.log('Complete Workflow:', workflowResult ? '✅ PASS' : '❌ FAIL');
  
  console.log('\n🎯 Integration Tests Result:', workflowResult ? '✅ INTEGRATION TESTS PASSED' : '❌ INTEGRATION TESTS FAILED');
  
  return workflowResult;
}

// Run tests if this file is executed directly
if (require.main === module) {
  runIntegrationTests().then(success => process.exit(success ? 0 : 1));
}

export { runIntegrationTests };
```

### **Complete Testing Workflow (MANDATORY)**
Follow this exact sequence for complete testing:

#### **Step 1: Development Mode Setup**
```bash
# Start in development mode
npm run dev

# Verify server is running
curl http://localhost:3000/health
```

#### **Step 2: Run All Tests**
```bash
# Run TypeScript tests directly (NO Jest/Mocha)
npx ts-node test/natural-request.test.ts
npx ts-node test/auth.test.ts
npx ts-node test/integration.test.ts

# Or run all tests with a simple script
npx ts-node test/run-all-tests.ts
```

#### **Step 3: Manual Testing (REQUIRED)**
```bash
# Test REST API
curl -X POST http://localhost:3000/run-natural-function \
  -H "Content-Type: application/json" \
  -d '{
    "userAddress": "0x1234567890abcdef",
    "apiKey": "your-api-key",
    "prompt": "Test natural function"
  }'

# Test auth link generation
curl -X POST http://localhost:3000/auth-link \
  -H "Content-Type: application/json" \
  -d '{
    "userAddress": "0x1234567890abcdef",
    "provider": "gmail"
  }'

# Test auth status
curl -X GET http://localhost:3000/auth-status/0x1234567890abcdef
```

#### **Step 4: Socket.IO Testing (REQUIRED)**
```typescript
// test/socket-manual.test.ts
import { io as Client } from 'socket.io-client';

const client = Client('http://localhost:3000');

client.on('connect', () => {
  console.log('Connected to Socket.IO server');
  
  // Test natural function via Socket.IO
  client.emit('natural-function', {
    userAddress: '0x1234567890abcdef',
    apiKey: 'test-api-key',
    prompt: 'Socket.IO test'
  });
});

client.on('response', (data) => {
  console.log('Received response:', data);
  client.disconnect();
});

client.on('progress', (data) => {
  console.log('Progress update:', data);
});

client.on('error', (data) => {
  console.error('Error:', data);
  client.disconnect();
});
```
